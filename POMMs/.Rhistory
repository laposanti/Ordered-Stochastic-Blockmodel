cat(paste0("Estimation of the SST model, K=", K_est, "\n"))
cat(paste0("Begin cycle at:", date(), "\n"))
estimation_control <- list(z = 1, sigma_squared = 0, mu_vec = 1, K = 0, P = 1)
chains <- adaptive_MCMC_orderstats(Y_ij = Y_ij, N_ij = N_ij,
estimation_control = estimation_control,
ground_truth = ground_truth,
n = n, N_iter = N_iter, n_chains = n_chains,
optimal_acceptance_rate = optimal_acceptance_rate, K = K_est,
seed = chains_seeds, model = 'SST', t = iteration, custom_init = custom_init)
my_names <- paste0("chain", rep(1, n_chains))
names(chains) <- my_names
for (i_to_be_saved in 1:n_chains) {
filename_SST <- paste0("True_Model", true_model, "Est_model_SST_True_K", file + 2, "_N", n, "iteration", which(t == iteration), "_estK", K_est, ".RDS")
saveRDS(object = chains[[i_to_be_saved]], file = filename_SST) # saving results
}
custom_init <- list(z = chains$chain1$est_containers$z[, N_iter],
P = chains$chain1$est_containers$P[, , N_iter],
mu_vec = chains$chain1$est_containers$mu_vec[, N_iter])
cat(paste0(33 - which(t == iteration), " to go!!\n"))
}
}
registerDoRNG(seed = 20)
foreach(K_est = c(2:7)) %dopar% {
setwd(paste0("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/results/model selection/K", file + 2, "true/raw/K", K_est))
custom_init <- NA
chains_seeds <- list(21)
n_chains <- 1
for (iteration in t) {
cat(paste0("Estimation of the SST model, K=", K_est, "\n"))
cat(paste0("Begin cycle at:", date(), "\n"))
estimation_control <- list(z = 1, sigma_squared = 0, mu_vec = 1, K = 0, P = 1)
chains <- adaptive_MCMC_orderstats(Y_ij = Y_ij, N_ij = N_ij,
estimation_control = estimation_control,
ground_truth = ground_truth,
n = n, N_iter = N_iter, n_chains = n_chains,
optimal_acceptance_rate = optimal_acceptance_rate, K = K_est,
seed = chains_seeds, model = 'SST', t = iteration, custom_init = custom_init)
my_names <- paste0("chain", rep(1, n_chains))
names(chains) <- my_names
for (i_to_be_saved in 1:n_chains) {
filename_SST <- paste0("True_Model", true_model, "Est_model_SST_True_K", file + 2, "_N", n, "iteration", which(t == iteration), "_estK", K_est, ".RDS")
saveRDS(object = chains[[i_to_be_saved]], file = filename_SST) # saving results
}
custom_init <- list(z = chains$chain1$est_containers$z[, N_iter],
P = chains$chain1$est_containers$P[, , N_iter],
mu_vec = chains$chain1$est_containers$mu_vec[, N_iter])
cat(paste0(33 - which(t == iteration), " to go!!\n"))
}
}
source("~/Desktop/Nial/POMM_pairwise/POMMs/Model_selection.R", echo=TRUE)
optimal_acceptance_rate <- 0.235
N_iter <- 40000
i <- seq(50, 0, -1.02)
t <- (i / length(i)) ^ 5
t = t[-c(2,4,6,7,9,10,12)]
t = t[-c(seq(4,40,4))]
registerDoRNG(seed = 20)
foreach(K_est = c(2:7)) %do% {
setwd(paste0("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/results/model selection/K", file + 2, "true/raw/K", K_est))
custom_init <- NA
chains_seeds <- list(21)
n_chains <- 1
for (iteration in t) {
cat(paste0("Estimation of the SST model, K=", K_est, "\n"))
cat(paste0("Begin cycle at:", date(), "\n"))
estimation_control <- list(z = 1, sigma_squared = 0, mu_vec = 1, K = 0, P = 1)
chains <- adaptive_MCMC_orderstats(Y_ij = Y_ij, N_ij = N_ij,
estimation_control = estimation_control,
ground_truth = ground_truth,
n = n, N_iter = N_iter, n_chains = n_chains,
optimal_acceptance_rate = optimal_acceptance_rate, K = K_est,
seed = chains_seeds, model = 'SST', t = iteration, custom_init = custom_init)
my_names <- paste0("chain", rep(1, n_chains))
names(chains) <- my_names
for (i_to_be_saved in 1:n_chains) {
filename_SST <- paste0("True_Model", true_model, "Est_model_SST_True_K", file + 2, "_N", n, "iteration", which(t == iteration), "_estK", K_est, ".RDS")
saveRDS(object = chains[[i_to_be_saved]], file = filename_SST) # saving results
}
custom_init <- list(z = chains$chain1$est_containers$z[, N_iter],
P = chains$chain1$est_containers$P[, , N_iter],
mu_vec = chains$chain1$est_containers$mu_vec[, N_iter])
cat(paste0(33 - which(t == iteration), " to go!!\n"))
}
}
source("~/Desktop/Nial/POMM_pairwise/POMMs/Model_selection.R", echo=TRUE)
source("~/Desktop/Nial/POMM_pairwise/POMMs/Model_selection.R", echo=TRUE)
setwd("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/")
source("./model_auxiliary_functions/Functions_priorSST.R")
source("./Metropolis_within_Gibbs_code.R")
source("./model_auxiliary_functions/MCMC_functions.R")
is.simulation=T
true_model = 'SST'
est_model = 'SST'
#where the data are stored
data_wd<- "/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/Data/Simulation_data/"
filenames <- list.files(pattern = paste0(true_model),path = data_wd)
#choose which data you want to use
# Choose which data you want to use
for(file in 1:length(filenames)){
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[file]))
N_ij <- data_to_be_estimated$N_ij
n <- nrow(N_ij)
Y_ij <- data_to_be_estimated$Y_ij
K <- data_to_be_estimated$ground_truth$K
ground_truth <- data_to_be_estimated$ground_truth
cat(paste0("True data--->", filenames[file], "\n"))
################################################################################
# Decide for how many Ks we want to compute the marginal posterior
################################################################################
optimal_acceptance_rate <- 0.235
N_iter <- 40000
i <- seq(50, 0, -1.02)
t <- (i / length(i)) ^ 5
t = t[-c(2,4,6,7,9,10,12)]
t = t[-c(seq(4,40,4))]
registerDoRNG(seed = 20)
foreach(K_est = c(2:7)) %do% {
setwd(paste0("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/results/model selection/K", file + 2, "true/raw/K", K_est))
custom_init <- NA
chains_seeds <- list(21)
n_chains <- 1
for (iteration in t) {
cat(paste0("Estimation of the SST model, K=", K_est, "\n"))
cat(paste0("Begin cycle at:", date(), "\n"))
estimation_control <- list(z = 1, sigma_squared = 0, mu_vec = 1, K = 0, P = 1)
chains <- adaptive_MCMC_orderstats(Y_ij = Y_ij, N_ij = N_ij,
estimation_control = estimation_control,
ground_truth = ground_truth,
n = n, N_iter = N_iter, n_chains = n_chains,
optimal_acceptance_rate = optimal_acceptance_rate, K = K_est,
seed = chains_seeds, model = 'SST', t = iteration, custom_init = custom_init)
my_names <- paste0("chain", rep(1, n_chains))
names(chains) <- my_names
for (i_to_be_saved in 1:n_chains) {
filename_SST <- paste0("True_Model", true_model, "Est_model_SST_True_K", file + 2, "_N", n, "iteration", which(t == iteration), "_estK", K_est, ".RDS")
saveRDS(object = chains[[i_to_be_saved]], file = filename_SST) # saving results
}
custom_init <- list(z = chains$chain1$est_containers$z[, N_iter],
P = chains$chain1$est_containers$P[, , N_iter],
mu_vec = chains$chain1$est_containers$mu_vec[, N_iter])
cat(paste0(33 - which(t == iteration), " to go!!\n"))
}
}
}
getwd()
setwd("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/")
source("./model_auxiliary_functions/Functions_priorSST.R")
source("./Metropolis_within_Gibbs_code.R")
source("./model_auxiliary_functions/MCMC_functions.R")
getwd()
source("~/Desktop/Nial/POMM_pairwise/POMMs/Model_selection.R", echo=TRUE)
getwd()
save_dir = paste0("./results/model selection/K", file + 2, "true/raw/K", K_est))
save_dir = paste0("./results/model selection/K", file + 2, "true/raw/K", K_est)
save_dir
source("~/Desktop/Nial/POMM_pairwise/POMMs/Model_selection.R", echo=TRUE)
i <- seq(0, 50, +1.02)
t <- (i / length(i)) ^ 5
t
round(9.980016e-01)
length(filenames)
filenames <- list.files(pattern = paste0(true_model),path = data_wd)
#choose which data you want to use
# Choose which data you want to use
registerDoRNG(seed=20)
foreach(file = 1:length(filenames)) %dopar%{
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[file]))
N_ij <- data_to_be_estimated$N_ij
n <- nrow(N_ij)
Y_ij <- data_to_be_estimated$Y_ij
K <- data_to_be_estimated$ground_truth$K
ground_truth <- data_to_be_estimated$ground_truth
cat(paste0("True data--->", filenames[file], "\n"))
################################################################################
# Decide for how many Ks we want to compute the marginal posterior
################################################################################
optimal_acceptance_rate <- 0.235
N_iter <- 40000
i <- seq(0, 50, +1.02)
t <- (i / length(i)) ^ 5
registerDoRNG(seed = 20)
foreach(K_est = c(2:7)) %do% {
save_dir = paste0("./results/model selection/K", file + 2, "true/raw/K", K_est)
custom_init <- NA
chains_seeds <- list(21)
n_chains <- 1
for (iteration in t) {
cat(paste0("Estimation of the SST model, K=", K_est, "\n"))
cat(paste0("Begin cycle at:", date(), "\n"))
estimation_control <- list(z = 1, sigma_squared = 0, mu_vec = 1, K = 0, P = 1)
chains <- adaptive_MCMC_orderstats(Y_ij = Y_ij, N_ij = N_ij,
estimation_control = estimation_control,
ground_truth = ground_truth,
n = n, N_iter = N_iter, n_chains = n_chains,
optimal_acceptance_rate = optimal_acceptance_rate, K = K_est,
seed = chains_seeds, model = 'SST', t = iteration, custom_init = custom_init)
my_names <- paste0("chain", rep(1, n_chains))
names(chains) <- my_names
for (i_to_be_saved in 1:n_chains) {
filename_SST <- paste0(save_dir,"True_Model", true_model, "Est_model_SST_True_K", file + 2, "_N", n, "iteration", which(t == iteration), "_estK", K_est, ".RDS")
saveRDS(object = chains[[i_to_be_saved]], file = filename_SST) # saving results
}
custom_init <- list(z = chains$chain1$est_containers$z[, N_iter],
P = chains$chain1$est_containers$P[, , N_iter],
mu_vec = chains$chain1$est_containers$mu_vec[, N_iter])
cat(paste0(33 - which(t == iteration), " to go!!\n"))
}
}
}
plan(multisession, workers= length(filenames), gc = TRUE)
foreach(file = 1:length(filenames), .options.future = list(globals = structure(F, seed=TRUE))) %dofuture% {
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[file]))
N_ij <- data_to_be_estimated$N_ij
n <- nrow(N_ij)
Y_ij <- data_to_be_estimated$Y_ij
K <- data_to_be_estimated$ground_truth$K
ground_truth <- data_to_be_estimated$ground_truth
cat(paste0("True data--->", filenames[file], "\n"))
################################################################################
# Decide for how many Ks we want to compute the marginal posterior
################################################################################
optimal_acceptance_rate <- 0.235
N_iter <- 40000
i <- seq(0, 50, +1.02)
t <- (i / length(i)) ^ 5
registerDoRNG(seed = 20)
foreach(K_est = c(2:7)) %do% {
save_dir = paste0("./results/model selection/K", file + 2, "true/raw/K", K_est)
custom_init <- NA
chains_seeds <- list(21)
n_chains <- 1
for (iteration in t) {
cat(paste0("Estimation of the SST model, K=", K_est, "\n"))
cat(paste0("Begin cycle at:", date(), "\n"))
estimation_control <- list(z = 1, sigma_squared = 0, mu_vec = 1, K = 0, P = 1)
chains <- adaptive_MCMC_orderstats(Y_ij = Y_ij, N_ij = N_ij,
estimation_control = estimation_control,
ground_truth = ground_truth,
n = n, N_iter = N_iter, n_chains = n_chains,
optimal_acceptance_rate = optimal_acceptance_rate, K = K_est,
seed = chains_seeds, model = 'SST', t = iteration, custom_init = custom_init)
my_names <- paste0("chain", rep(1, n_chains))
names(chains) <- my_names
for (i_to_be_saved in 1:n_chains) {
filename_SST <- paste0(save_dir,"True_Model", true_model, "Est_model_SST_True_K", file + 2, "_N", n, "iteration", which(t == iteration), "_estK", K_est, ".RDS")
saveRDS(object = chains[[i_to_be_saved]], file = filename_SST) # saving results
}
custom_init <- list(z = chains$chain1$est_containers$z[, N_iter],
P = chains$chain1$est_containers$P[, , N_iter],
mu_vec = chains$chain1$est_containers$mu_vec[, N_iter])
cat(paste0(33 - which(t == iteration), " to go!!\n"))
}
}
}
plan(multisession, workers= length(filenames), gc = TRUE)
foreach(file = 1:length(filenames), .options.future = list(globals = structure(T, seed=TRUE))) %dofuture% {
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[file]))
N_ij <- data_to_be_estimated$N_ij
n <- nrow(N_ij)
Y_ij <- data_to_be_estimated$Y_ij
K <- data_to_be_estimated$ground_truth$K
ground_truth <- data_to_be_estimated$ground_truth
cat(paste0("True data--->", filenames[file], "\n"))
################################################################################
# Decide for how many Ks we want to compute the marginal posterior
################################################################################
optimal_acceptance_rate <- 0.235
N_iter <- 40000
i <- seq(0, 50, +1.02)
t <- (i / length(i)) ^ 5
registerDoRNG(seed = 20)
foreach(K_est = c(2:7)) %do% {
save_dir = paste0("./results/model selection/K", file + 2, "true/raw/K", K_est)
custom_init <- NA
chains_seeds <- list(21)
n_chains <- 1
for (iteration in t) {
cat(paste0("Estimation of the SST model, K=", K_est, "\n"))
cat(paste0("Begin cycle at:", date(), "\n"))
estimation_control <- list(z = 1, sigma_squared = 0, mu_vec = 1, K = 0, P = 1)
chains <- adaptive_MCMC_orderstats(Y_ij = Y_ij, N_ij = N_ij,
estimation_control = estimation_control,
ground_truth = ground_truth,
n = n, N_iter = N_iter, n_chains = n_chains,
optimal_acceptance_rate = optimal_acceptance_rate, K = K_est,
seed = chains_seeds, model = 'SST', t = iteration, custom_init = custom_init)
my_names <- paste0("chain", rep(1, n_chains))
names(chains) <- my_names
for (i_to_be_saved in 1:n_chains) {
filename_SST <- paste0(save_dir,"True_Model", true_model, "Est_model_SST_True_K", file + 2, "_N", n, "iteration", which(t == iteration), "_estK", K_est, ".RDS")
saveRDS(object = chains[[i_to_be_saved]], file = filename_SST) # saving results
}
custom_init <- list(z = chains$chain1$est_containers$z[, N_iter],
P = chains$chain1$est_containers$P[, , N_iter],
mu_vec = chains$chain1$est_containers$mu_vec[, N_iter])
cat(paste0(33 - which(t == iteration), " to go!!\n"))
}
}
}
#choose which data you want to use
# Choose which data you want to use
registerDoFuture()
plan(multisession, workers= length(filenames), gc = TRUE)
foreach(file = 1:length(filenames), .options.future = list(globals = structure(T, seed=TRUE))) %dofuture% {
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[file]))
N_ij <- data_to_be_estimated$N_ij
n <- nrow(N_ij)
Y_ij <- data_to_be_estimated$Y_ij
K <- data_to_be_estimated$ground_truth$K
ground_truth <- data_to_be_estimated$ground_truth
cat(paste0("True data--->", filenames[file], "\n"))
################################################################################
# Decide for how many Ks we want to compute the marginal posterior
################################################################################
optimal_acceptance_rate <- 0.235
N_iter <- 40000
i <- seq(0, 50, +1.02)
t <- (i / length(i)) ^ 5
registerDoRNG(seed = 20)
foreach(K_est = c(2:7)) %do% {
save_dir = paste0("./results/model selection/K", file + 2, "true/raw/K", K_est)
custom_init <- NA
chains_seeds <- list(21)
n_chains <- 1
for (iteration in t) {
cat(paste0("Estimation of the SST model, K=", K_est, "\n"))
cat(paste0("Begin cycle at:", date(), "\n"))
estimation_control <- list(z = 1, sigma_squared = 0, mu_vec = 1, K = 0, P = 1)
chains <- adaptive_MCMC_orderstats(Y_ij = Y_ij, N_ij = N_ij,
estimation_control = estimation_control,
ground_truth = ground_truth,
n = n, N_iter = N_iter, n_chains = n_chains,
optimal_acceptance_rate = optimal_acceptance_rate, K = K_est,
seed = chains_seeds, model = 'SST', t = iteration, custom_init = custom_init)
my_names <- paste0("chain", rep(1, n_chains))
names(chains) <- my_names
for (i_to_be_saved in 1:n_chains) {
filename_SST <- paste0(save_dir,"True_Model", true_model, "Est_model_SST_True_K", file + 2, "_N", n, "iteration", which(t == iteration), "_estK", K_est, ".RDS")
saveRDS(object = chains[[i_to_be_saved]], file = filename_SST) # saving results
}
custom_init <- list(z = chains$chain1$est_containers$z[, N_iter],
P = chains$chain1$est_containers$P[, , N_iter],
mu_vec = chains$chain1$est_containers$mu_vec[, N_iter])
cat(paste0(33 - which(t == iteration), " to go!!\n"))
}
}
}
#choose which data you want to use
# Choose which data you want to use
registerDoFuture()
plan(multisession, workers= length(filenames), gc = TRUE)
foreach(file = 1:length(filenames), .options.future = list(globals = structure(T, seed=TRUE))) %dofuture% {
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[file]))
N_ij <- data_to_be_estimated$N_ij
n <- nrow(N_ij)
Y_ij <- data_to_be_estimated$Y_ij
K <- data_to_be_estimated$ground_truth$K
ground_truth <- data_to_be_estimated$ground_truth
cat(paste0("True data--->", filenames[file], "\n"))
################################################################################
# Decide for how many Ks we want to compute the marginal posterior
################################################################################
optimal_acceptance_rate <- 0.235
N_iter <- 40000
i <- seq(0, 50, +1.02)
t <- (i / length(i)) ^ 5
foreach(K_est = c(2:7)) %do% {
save_dir = paste0("./results/model selection/K", file + 2, "true/raw/K", K_est)
custom_init <- NA
chains_seeds <- list(21)
n_chains <- 1
for (iteration in t) {
cat(paste0("Estimation of the SST model, K=", K_est, "\n"))
cat(paste0("Begin cycle at:", date(), "\n"))
estimation_control <- list(z = 1, sigma_squared = 0, mu_vec = 1, K = 0, P = 1)
chains <- adaptive_MCMC_orderstats(Y_ij = Y_ij, N_ij = N_ij,
estimation_control = estimation_control,
ground_truth = ground_truth,
n = n, N_iter = N_iter, n_chains = n_chains,
optimal_acceptance_rate = optimal_acceptance_rate, K = K_est,
seed = chains_seeds, model = 'SST', t = iteration, custom_init = custom_init)
my_names <- paste0("chain", rep(1, n_chains))
names(chains) <- my_names
for (i_to_be_saved in 1:n_chains) {
filename_SST <- paste0(save_dir,"True_Model", true_model, "Est_model_SST_True_K", file + 2, "_N", n, "iteration", which(t == iteration), "_estK", K_est, ".RDS")
saveRDS(object = chains[[i_to_be_saved]], file = filename_SST) # saving results
}
custom_init <- list(z = chains$chain1$est_containers$z[, N_iter],
P = chains$chain1$est_containers$P[, , N_iter],
mu_vec = chains$chain1$est_containers$mu_vec[, N_iter])
cat(paste0(33 - which(t == iteration), " to go!!\n"))
}
}
}
setwd("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/")
source("./model_auxiliary_functions/Functions_priorSST.R")
source("./Metropolis_within_Gibbs_code.R")
source("./model_auxiliary_functions/MCMC_functions.R")
is.simulation=T
true_model = 'SST'
est_model = 'SST'
#where the data are stored
data_wd<- "/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/Data/Simulation_data/"
filenames <- list.files(pattern = paste0(true_model),path = data_wd)
#choose which data you want to use
# Choose which data you want to use
registerDoFuture()
plan(multisession, workers= length(filenames), gc = TRUE)
foreach(file = 1:length(filenames), .options.future = list(globals = structure(T, seed=TRUE))) %dofuture% {
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[file]))
N_ij <- data_to_be_estimated$N_ij
n <- nrow(N_ij)
Y_ij <- data_to_be_estimated$Y_ij
K <- data_to_be_estimated$ground_truth$K
ground_truth <- data_to_be_estimated$ground_truth
cat(paste0("True data--->", filenames[file], "\n"))
################################################################################
# Decide for how many Ks we want to compute the marginal posterior
################################################################################
optimal_acceptance_rate <- 0.235
N_iter <- 40000
i <- seq(0, 50, +1.02)
t <- (i / length(i)) ^ 5
foreach(K_est = c(2:7)) %do% {
save_dir = paste0("./results/model selection/K", file + 2, "true/raw/K", K_est)
custom_init <- NA
chains_seeds <- list(21)
n_chains <- 1
for (iteration in t) {
cat(paste0("Estimation of the SST model, K=", K_est, "\n"))
cat(paste0("Begin cycle at:", date(), "\n"))
estimation_control <- list(z = 1, sigma_squared = 0, mu_vec = 1, K = 0, P = 1)
chains <- adaptive_MCMC_orderstats(Y_ij = Y_ij, N_ij = N_ij,
estimation_control = estimation_control,
ground_truth = ground_truth,
n = n, N_iter = N_iter, n_chains = n_chains,
optimal_acceptance_rate = optimal_acceptance_rate, K = K_est,
seed = chains_seeds, model = 'SST', t = iteration, custom_init = custom_init)
my_names <- paste0("chain", rep(1, n_chains))
names(chains) <- my_names
for (i_to_be_saved in 1:n_chains) {
filename_SST <- paste0(save_dir,"True_Model", true_model, "Est_model_SST_True_K", file + 2, "_N", n, "iteration", which(t == iteration), "_estK", K_est, ".RDS")
saveRDS(object = chains[[i_to_be_saved]], file = filename_SST) # saving results
}
custom_init <- list(z = chains$chain1$est_containers$z[, N_iter],
P = chains$chain1$est_containers$P[, , N_iter],
mu_vec = chains$chain1$est_containers$mu_vec[, N_iter])
cat(paste0(33 - which(t == iteration), " to go!!\n"))
}
}
}
length(filenames)
#choose which data you want to use
# Choose which data you want to use
for(file in 1:length(filenames)){
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[file]))
N_ij <- data_to_be_estimated$N_ij
n <- nrow(N_ij)
Y_ij <- data_to_be_estimated$Y_ij
K <- data_to_be_estimated$ground_truth$K
ground_truth <- data_to_be_estimated$ground_truth
cat(paste0("True data--->", filenames[file], "\n"))
################################################################################
# Decide for how many Ks we want to compute the marginal posterior
################################################################################
optimal_acceptance_rate <- 0.235
N_iter <- 40000
i <- seq(0, 50, +1.02)
t <- (i / length(i)) ^ 5
registerDoFuture()
plan(multisession, workers= length(filenames), gc = TRUE)
foreach(K_est = c(2:7), .options.future = list(globals = structure(T, seed=TRUE))) %dofuture% {
save_dir = paste0("./results/model selection/K", file + 2, "true/raw/K", K_est)
custom_init <- NA
chains_seeds <- list(21)
n_chains <- 1
for (iteration in t) {
cat(paste0("Estimation of the SST model, K=", K_est, "\n"))
cat(paste0("Begin cycle at:", date(), "\n"))
estimation_control <- list(z = 1, sigma_squared = 0, mu_vec = 1, K = 0, P = 1)
chains <- adaptive_MCMC_orderstats(Y_ij = Y_ij, N_ij = N_ij,
estimation_control = estimation_control,
ground_truth = ground_truth,
n = n, N_iter = N_iter, n_chains = n_chains,
optimal_acceptance_rate = optimal_acceptance_rate, K = K_est,
seed = chains_seeds, model = 'SST', t = iteration, custom_init = custom_init)
my_names <- paste0("chain", rep(1, n_chains))
names(chains) <- my_names
for (i_to_be_saved in 1:n_chains) {
filename_SST <- paste0(save_dir,"True_Model", true_model, "Est_model_SST_True_K", file + 2, "_N", n, "iteration", which(t == iteration), "_estK", K_est, ".RDS")
saveRDS(object = chains[[i_to_be_saved]], file = filename_SST) # saving results
}
custom_init <- list(z = chains$chain1$est_containers$z[, N_iter],
P = chains$chain1$est_containers$P[, , N_iter],
mu_vec = chains$chain1$est_containers$mu_vec[, N_iter])
cat(paste0(33 - which(t == iteration), " to go!!\n"))
}
}
}
source("~/Desktop/Nial/POMM_pairwise/POMMs/Model_selection.R", echo=TRUE)
n_chains
source("~/Desktop/Nial/POMM_pairwise/POMMs/Model_selection.R", echo=TRUE)
#choose which data you want to use
# Choose which data you want to use
file=2
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[file]))
N_ij <- data_to_be_estimated$N_ij
n <- nrow(N_ij)
Y_ij <- data_to_be_estimated$Y_ij
K <- data_to_be_estimated$ground_truth$K
ground_truth <- data_to_be_estimated$ground_truth
cat(paste0("True data--->", filenames[file], "\n"))
