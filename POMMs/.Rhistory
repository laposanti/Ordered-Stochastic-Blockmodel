est_model = character(),
K_est = numeric(),
looic = numeric())
for(i in 1:9){
Y_ij = uploaded_results[[i]]$Y_ij
N_ij =  uploaded_results[[i]]$N_ij
z_i = uploaded_results[[i]]$est_containers$z
theta = uploaded_results[[i]]$est_containers$theta
num_samples = ncol(z_i)
filtering_obs = which(upper.tri(N_ij) & N_ij!= 0,arr.ind = T)
upper.tri.Y_ij = Y_ij[filtering_obs]
upper.tri.N_ij = N_ij[filtering_obs]
Y_pred = matrix(NA, nrow = num_samples,ncol = length(upper.tri.Y_ij))
llik = matrix(NA,  nrow = num_samples, ncol = length(upper.tri.Y_ij))
for(t in 1:num_samples){
z_chain_mat = vec2mat_0_P(z_i[,t], theta[,,t])
P_entry = inverse_logit_f(theta[,,t])
P_ij = calculate_victory_probabilities(z_mat =z_chain_mat, P = P_entry)
llik[t,] =  dbinom(upper.tri.Y_ij, upper.tri.N_ij, P_ij[filtering_obs],log = T)
Y_pred[t,] <- rbinom(length(upper.tri.Y_ij), upper.tri.N_ij,
P_ij[filtering_obs])
}
r_effs = loo::relative_eff(llik,rep(1,num_samples))
loo_model_fit = loo::loo(llik,cores = 3,save_psis = T,r_eff = r_effs)
df_model_choice = rbind(df_model_choice, data.frame(K_true = uploaded_results[[i]]$ground_truth$K,
true_model = uploaded_results[[i]]$ground_truth$model,
est_model = uploaded_results[[i]]$control_containers$est_model,
K_est = dim(theta)[1],
looic =loo_model_fit$looic))
}
df_model_choice%>%
ggplot(aes(K_est,looic))+
geom_point()
which.min(df_model_choice$)
df_model_choice
file=3
save_path = paste0(data_wd,matching_files$name[file])
drive_download(file = matching_files $id[file], path = save_path,overwrite = T)
uploaded_results = readRDS(save_path)
df_model_choice = data.frame(K_true = numeric(),
true_model = character(),
est_model = character(),
K_est = numeric(),
looic = numeric())
for(i in 1:9){
Y_ij = uploaded_results[[i]]$Y_ij
N_ij =  uploaded_results[[i]]$N_ij
z_i = uploaded_results[[i]]$est_containers$z
theta = uploaded_results[[i]]$est_containers$theta
num_samples = ncol(z_i)
filtering_obs = which(upper.tri(N_ij) & N_ij!= 0,arr.ind = T)
upper.tri.Y_ij = Y_ij[filtering_obs]
upper.tri.N_ij = N_ij[filtering_obs]
Y_pred = matrix(NA, nrow = num_samples,ncol = length(upper.tri.Y_ij))
llik = matrix(NA,  nrow = num_samples, ncol = length(upper.tri.Y_ij))
for(t in 1:num_samples){
z_chain_mat = vec2mat_0_P(z_i[,t], theta[,,t])
P_entry = inverse_logit_f(theta[,,t])
P_ij = calculate_victory_probabilities(z_mat =z_chain_mat, P = P_entry)
llik[t,] =  dbinom(upper.tri.Y_ij, upper.tri.N_ij, P_ij[filtering_obs],log = T)
Y_pred[t,] <- rbinom(length(upper.tri.Y_ij), upper.tri.N_ij,
P_ij[filtering_obs])
}
r_effs = loo::relative_eff(llik,rep(1,num_samples))
loo_model_fit = loo::loo(llik,cores = 3,save_psis = T,r_eff = r_effs)
df_model_choice = rbind(df_model_choice, data.frame(K_true = uploaded_results[[i]]$ground_truth$K,
true_model = uploaded_results[[i]]$ground_truth$model,
est_model = uploaded_results[[i]]$control_containers$est_model,
K_est = dim(theta)[1],
looic =loo_model_fit$looic))
}
num_samples
df_model_choice
#
#
# 2
# # Get the folder (if you already have it) or specify the path where you want to upload
folder_url <- "https://drive.google.com/drive/u/1/folders/1XKZh_eKciM3XqEc2bQX-e_H9iqOQ5dcZ"
folder <- drive_get(as_id(folder_url))
#where the data are stored
data_wd<- "./Data/Sim1_data/"
data_description = 'SST6'
filenames <- list.files(pattern = paste0(data_description),path = data_wd)
data_to_be_estimated <- readRDS(paste0(data_wd, "/", 'temp_1'))
recovery_capability = data_to_be_estimated$recovery_capability
N_ij <- data_to_be_estimated$N_ij
folder_url <- "https://drive.google.com/drive/u/1/folders/1XKZh_eKciM3XqEc2bQX-e_H9iqOQ5dcZ"
folder <- drive_get(as_id(folder_url))
# List all files in the folder
files_in_folder <- drive_ls(path = folder)
pattern <- "SST"
matching_files <- files_in_folder[grep(pattern, files_in_folder$name), ]
files_10 <- grep("Kest130", matching_files$name)
total_files = 1:length(matching_files$name)
file_to_analyse = setdiff(total_files,files_10)
data_wd = './results/MCMC_output/model_choice/WAIC_method/K5_true/'
matching_files
files_10 <- grep("Kest130", matching_files$name)
total_files = 1:length(matching_files$name)
file_to_analyse = setdiff(total_files,files_10)
data_wd = './results/MCMC_output/model_choice/WAIC_method/K5_true/'
file=3
save_path = paste0(data_wd,matching_files$name[file])
drive_download(file = matching_files $id[file], path = save_path,overwrite = T)
uploaded_results = readRDS(save_path)
df_model_choice = data.frame(K_true = numeric(),
true_model = character(),
est_model = character(),
K_est = numeric(),
looic = numeric())
for(i in 1:9){
Y_ij = uploaded_results[[i]]$Y_ij
N_ij =  uploaded_results[[i]]$N_ij
z_i = uploaded_results[[i]]$est_containers$z
theta = uploaded_results[[i]]$est_containers$theta
num_samples = ncol(z_i)
filtering_obs = which(upper.tri(N_ij) & N_ij!= 0,arr.ind = T)
upper.tri.Y_ij = Y_ij[filtering_obs]
upper.tri.N_ij = N_ij[filtering_obs]
Y_pred = matrix(NA, nrow = num_samples,ncol = length(upper.tri.Y_ij))
llik = matrix(NA,  nrow = num_samples, ncol = length(upper.tri.Y_ij))
for(t in 1:num_samples){
z_chain_mat = vec2mat_0_P(z_i[,t], theta[,,t])
P_entry = inverse_logit_f(theta[,,t])
P_ij = calculate_victory_probabilities(z_mat =z_chain_mat, P = P_entry)
llik[t,] =  dbinom(upper.tri.Y_ij, upper.tri.N_ij, P_ij[filtering_obs],log = T)
Y_pred[t,] <- rbinom(length(upper.tri.Y_ij), upper.tri.N_ij,
P_ij[filtering_obs])
}
r_effs = loo::relative_eff(llik,rep(1,num_samples))
loo_model_fit = loo::loo(llik,cores = 3,save_psis = T,r_eff = r_effs)
df_model_choice = rbind(df_model_choice, data.frame(K_true = uploaded_results[[i]]$ground_truth$K,
true_model = uploaded_results[[i]]$ground_truth$model,
est_model = uploaded_results[[i]]$control_containers$est_model,
K_est = dim(theta)[1],
looic =loo_model_fit$looic))
}
df_model_choice%>%
ggplot(aes(K_est,looic))+
geom_point()
which.min(df_model_choice$)
which.min(df_model_choice$looic)
data_wd = './results/MCMC_output/model_choice/WAIC_method/K5_true/'
for(for file in 1:3){
for(file in 1:3){
save_path = paste0(data_wd,matching_files$name[file])
drive_download(file = matching_files $id[file], path = save_path,overwrite = T)
uploaded_results = readRDS(save_path)
df_model_choice = data.frame(K_true = numeric(),
true_model = character(),
est_model = character(),
K_est = numeric(),
looic = numeric())
for(i in 1:9){
Y_ij = uploaded_results[[i]]$Y_ij
N_ij =  uploaded_results[[i]]$N_ij
z_i = uploaded_results[[i]]$est_containers$z
theta = uploaded_results[[i]]$est_containers$theta
num_samples = ncol(z_i)
filtering_obs = which(upper.tri(N_ij) & N_ij!= 0,arr.ind = T)
upper.tri.Y_ij = Y_ij[filtering_obs]
upper.tri.N_ij = N_ij[filtering_obs]
Y_pred = matrix(NA, nrow = num_samples,ncol = length(upper.tri.Y_ij))
llik = matrix(NA,  nrow = num_samples, ncol = length(upper.tri.Y_ij))
for(t in 1:num_samples){
z_chain_mat = vec2mat_0_P(z_i[,t], theta[,,t])
P_entry = inverse_logit_f(theta[,,t])
P_ij = calculate_victory_probabilities(z_mat =z_chain_mat, P = P_entry)
llik[t,] =  dbinom(upper.tri.Y_ij, upper.tri.N_ij, P_ij[filtering_obs],log = T)
Y_pred[t,] <- rbinom(length(upper.tri.Y_ij), upper.tri.N_ij,
P_ij[filtering_obs])
}
r_effs = loo::relative_eff(llik,rep(1,num_samples))
loo_model_fit = loo::loo(llik,cores = 3,save_psis = T,r_eff = r_effs)
df_model_choice = rbind(df_model_choice, data.frame(K_true = uploaded_results[[i]]$ground_truth$K,
true_model = uploaded_results[[i]]$ground_truth$model,
est_model = uploaded_results[[i]]$control_containers$est_model,
K_est = dim(theta)[1],
looic =loo_model_fit$looic))
}
}
df_model_choice%>%
ggplot(aes(K_est,looic,color = est_model))+
geom_point()
df_model_choice
data_wd = './results/MCMC_output/model_choice/WAIC_method/K6_true/'
df_model_choice = data.frame(K_true = numeric(),
true_model = character(),
est_model = character(),
K_est = numeric(),
looic = numeric())
for(file in 1:3){
save_path = paste0(data_wd,matching_files$name[file])
drive_download(file = matching_files $id[file], path = 'temp1',overwrite = T)
uploaded_results = readRDS(save_path)
for(i in 1:9){
Y_ij = uploaded_results[[i]]$Y_ij
N_ij =  uploaded_results[[i]]$N_ij
z_i = uploaded_results[[i]]$est_containers$z
theta = uploaded_results[[i]]$est_containers$theta
num_samples = ncol(z_i)
filtering_obs = which(upper.tri(N_ij) & N_ij!= 0,arr.ind = T)
upper.tri.Y_ij = Y_ij[filtering_obs]
upper.tri.N_ij = N_ij[filtering_obs]
Y_pred = matrix(NA, nrow = num_samples,ncol = length(upper.tri.Y_ij))
llik = matrix(NA,  nrow = num_samples, ncol = length(upper.tri.Y_ij))
for(t in 1:num_samples){
z_chain_mat = vec2mat_0_P(z_i[,t], theta[,,t])
P_entry = inverse_logit_f(theta[,,t])
P_ij = calculate_victory_probabilities(z_mat =z_chain_mat, P = P_entry)
llik[t,] =  dbinom(upper.tri.Y_ij, upper.tri.N_ij, P_ij[filtering_obs],log = T)
Y_pred[t,] <- rbinom(length(upper.tri.Y_ij), upper.tri.N_ij,
P_ij[filtering_obs])
}
r_effs = loo::relative_eff(llik,rep(1,num_samples))
loo_model_fit = loo::loo(llik,cores = 3,save_psis = T,r_eff = r_effs)
df_model_choice = rbind(df_model_choice, data.frame(K_true = uploaded_results[[i]]$ground_truth$K,
true_model = uploaded_results[[i]]$ground_truth$model,
est_model = uploaded_results[[i]]$control_containers$est_model,
K_est = dim(theta)[1],
looic =loo_model_fit$looic))
}
}
pattern <- "SST"
data_wd = './results/MCMC_output/model_choice/WAIC_method/K6_true/'
df_model_choice = data.frame(K_true = numeric(),
true_model = character(),
est_model = character(),
K_est = numeric(),
looic = numeric())
df_model_choice = data.frame(K_true = numeric(),
true_model = character(),
est_model = character(),
K_est = numeric(),
looic = numeric())
for(file in 1:3){
save_path = paste0(data_wd,'temp1')
drive_download(file = matching_files $id[file], path = save_path,overwrite = T)
uploaded_results = readRDS(save_path)
for(i in 1:9){
Y_ij = uploaded_results[[i]]$Y_ij
N_ij =  uploaded_results[[i]]$N_ij
z_i = uploaded_results[[i]]$est_containers$z
theta = uploaded_results[[i]]$est_containers$theta
num_samples = ncol(z_i)
filtering_obs = which(upper.tri(N_ij) & N_ij!= 0,arr.ind = T)
upper.tri.Y_ij = Y_ij[filtering_obs]
upper.tri.N_ij = N_ij[filtering_obs]
Y_pred = matrix(NA, nrow = num_samples,ncol = length(upper.tri.Y_ij))
llik = matrix(NA,  nrow = num_samples, ncol = length(upper.tri.Y_ij))
for(t in 1:num_samples){
z_chain_mat = vec2mat_0_P(z_i[,t], theta[,,t])
P_entry = inverse_logit_f(theta[,,t])
P_ij = calculate_victory_probabilities(z_mat =z_chain_mat, P = P_entry)
llik[t,] =  dbinom(upper.tri.Y_ij, upper.tri.N_ij, P_ij[filtering_obs],log = T)
Y_pred[t,] <- rbinom(length(upper.tri.Y_ij), upper.tri.N_ij,
P_ij[filtering_obs])
}
r_effs = loo::relative_eff(llik,rep(1,num_samples))
loo_model_fit = loo::loo(llik,cores = 3,save_psis = T,r_eff = r_effs)
df_model_choice = rbind(df_model_choice, data.frame(K_true = uploaded_results[[i]]$ground_truth$K,
true_model = uploaded_results[[i]]$ground_truth$model,
est_model = uploaded_results[[i]]$control_containers$est_model,
K_est = dim(theta)[1],
looic =loo_model_fit$looic))
}
}
data_wd = './results/MCMC_output/model_choice/WAIC_method/K6_true/'
df_model_choice = data.frame(K_true = numeric(),
true_model = character(),
est_model = character(),
K_est = numeric(),
looic = numeric())
for(file in 1:3){
save_path = paste0(data_wd,'temp1.rds')
drive_download(file = matching_files $id[file], path = save_path,overwrite = T)
uploaded_results = readRDS(save_path)
for(i in 1:9){
Y_ij = uploaded_results[[i]]$Y_ij
N_ij =  uploaded_results[[i]]$N_ij
z_i = uploaded_results[[i]]$est_containers$z
theta = uploaded_results[[i]]$est_containers$theta
num_samples = ncol(z_i)
filtering_obs = which(upper.tri(N_ij) & N_ij!= 0,arr.ind = T)
upper.tri.Y_ij = Y_ij[filtering_obs]
upper.tri.N_ij = N_ij[filtering_obs]
Y_pred = matrix(NA, nrow = num_samples,ncol = length(upper.tri.Y_ij))
llik = matrix(NA,  nrow = num_samples, ncol = length(upper.tri.Y_ij))
for(t in 1:num_samples){
z_chain_mat = vec2mat_0_P(z_i[,t], theta[,,t])
P_entry = inverse_logit_f(theta[,,t])
P_ij = calculate_victory_probabilities(z_mat =z_chain_mat, P = P_entry)
llik[t,] =  dbinom(upper.tri.Y_ij, upper.tri.N_ij, P_ij[filtering_obs],log = T)
Y_pred[t,] <- rbinom(length(upper.tri.Y_ij), upper.tri.N_ij,
P_ij[filtering_obs])
}
r_effs = loo::relative_eff(llik,rep(1,num_samples))
loo_model_fit = loo::loo(llik,cores = 3,save_psis = T,r_eff = r_effs)
df_model_choice = rbind(df_model_choice, data.frame(K_true = uploaded_results[[i]]$ground_truth$K,
true_model = uploaded_results[[i]]$ground_truth$model,
est_model = uploaded_results[[i]]$control_containers$est_model,
K_est = dim(theta)[1],
looic =loo_model_fit$looic))
}
}
df_model_choice%>%
ggplot(aes(K_est,looic,color = est_model))+
geom_point()
df_model_choice%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point()+
labs(title = "Looic for different models",
subtitle = 'lower values are better',
caption = paste0("true data ~ K = ", df_model_choice$K_true[1],", model = "df_model_choice$true_model[1]))
df_model_choice%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point()+
labs(title = "Looic for different models",
subtitle = 'lower values are better',
caption = paste0("true data ~ K = ", df_model_choice$K_true[1],", model = ",df_model_choice$true_model[1]))
df_model_choice%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point()+
labs(title = "Looic for different models",
subtitle = 'lower values are better',
caption = paste0("true data ~ model = ",df_model_choice$true_model[1]",K = "df_model_choice$K_true[1]))
df_model_choice%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point()+
labs(title = "Looic for different models",
subtitle = 'lower values are better',
caption = paste0("true data ~ model = ",df_model_choice$true_model[1], ",K = "df_model_choice$K_true[1]))
df_model_choice%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point()+
labs(title = "Looic for different models",
subtitle = 'lower values are better',
caption = paste0("true data ~ model = ",df_model_choice$true_model[1], ",K = ",df_model_choice$K_true[1]))
df_model_choice%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point()+
labs(title = "Looic for different models",
subtitle = 'lower values are better',
caption = paste0("true data ~ ",df_model_choice$true_model[1], "model ,K = ",df_model_choice$K_true[1]))
df_model_choice%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point()+
labs(title = "Looic for different models",
subtitle = 'lower values are better',
caption = paste0("true data ~ ",df_model_choice$true_model[1], " model ,K = ",df_model_choice$K_true[1]))
df_model_choice%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point()+
labs(title = "Looic for different models",
subtitle = 'Lower values are better',
caption = paste0("true data ~ ",df_model_choice$true_model[1], " model ,K = ",df_model_choice$K_true[1]))
df_model_choice%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point()+
labs(title = "Looic for different models",
subtitle = 'Lower values are better',
caption = paste0("True data ~ ",df_model_choice$true_model[1], " model ,K = ",df_model_choice$K_true[1]))
data_description = 'SST5'
filenames <- list.files(pattern = paste0(data_description),path = data_wd)
data_to_be_estimated <- readRDS(paste0(data_wd, "/", 'temp_1'))
recovery_capability = data_to_be_estimated$recovery_capability
#where the data are stored
data_wd<- "./Data/Sim1_data/"
data_description = 'SST5'
filenames <- list.files(pattern = paste0(data_description),path = data_wd)
data_description = 'SST5'
filenames <- list.files(pattern = paste0(data_description),path = data_wd)
#where the data are stored
data_wd<- "./Data/Sim1_data/"
data_description = 'SST5'
filenames <- list.files(pattern = paste0(data_description),path = data_wd)
filenames
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[1]))
recovery_capability = data_to_be_estimated$recovery_capability
N_ij <- data_to_be_estimated$N_ij
n <- nrow(N_ij)
Y_ij <- data_to_be_estimated$Y_ij
K <- data_to_be_estimated$ground_truth$K
ground_truth <- data_to_be_estimated$ground_truth
choose_model_to_estimate = c('SST', 'WST','Simple')
#where the data are stored
data_wd<- "./Data/Sim1_data/"
data_description = 'SST3'
filenames <- list.files(pattern = paste0(data_description),path = data_wd)
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[1]))
Y_ij <- data_to_be_estimated$Y_ij
N_ij <- data_to_be_estimated$N_ij
recovery_capability = data_to_be_estimated$recovery_capability
n <- nrow(N_ij)
googledrive::drive_auth_configure(path = "./client_secret_573831164304-jqqj3i5mhvubbkkuifvtgkfsut8lse3g.apps.googleusercontent.com.json")
subject = "lapo.santi@ucdconnect.ie"
service_account_key = "./sonic-426715-75af23aca274.json"
googledrive::drive_deauth()
#
#
# 2
# # Get the folder (if you already have it) or specify the path where you want to upload
folder_url <- "https://drive.google.com/drive/u/1/folders/1QLqA5DfE1LSfqq7GJqDy3u5O2K7vwc8N"
googledrive::drive_auth(email = subject)
subject = "lapo.santi@ucdconnect.ie"
service_account_key = "./sonic-426715-75af23aca274.json"
googledrive::drive_deauth()
googledrive::drive_auth_configure(path = "./client_secret_573831164304-jqqj3i5mhvubbkkuifvtgkfsut8lse3g.apps.googleusercontent.com.json")
googledrive::drive_auth(email = subject)
folder_url <- "https://drive.google.com/drive/u/1/folders/1DGDTPwyDrrMWyjBC0NbZ4nnYlY_c2pRp"
folder <- drive_get(as_id(folder_url))
# List all files in the folder
files_in_folder <- drive_ls(path = folder)
pattern <- "SST"
matching_files <- files_in_folder[grep(pattern, files_in_folder$name), ]
files_10 <- grep("Kest130", matching_files$name)
total_files = 1:length(matching_files$name)
file_to_analyse = setdiff(total_files,files_10)
data_wd = './results/MCMC_output/model_choice/WAIC_method/K4_true/'
df_model_choice = data.frame(K_true = numeric(),
true_model = character(),
est_model = character(),
K_est = numeric(),
looic = numeric())
for(file in 1:3){
save_path = paste0(data_wd,'temp1.rds')
drive_download(file = matching_files $id[file], path = save_path,overwrite = T)
uploaded_results = readRDS(save_path)
for(i in 1:9){
Y_ij = uploaded_results[[i]]$Y_ij
N_ij =  uploaded_results[[i]]$N_ij
z_i = uploaded_results[[i]]$est_containers$z
theta = uploaded_results[[i]]$est_containers$theta
num_samples = ncol(z_i)
filtering_obs = which(upper.tri(N_ij) & N_ij!= 0,arr.ind = T)
upper.tri.Y_ij = Y_ij[filtering_obs]
upper.tri.N_ij = N_ij[filtering_obs]
Y_pred = matrix(NA, nrow = num_samples,ncol = length(upper.tri.Y_ij))
llik = matrix(NA,  nrow = num_samples, ncol = length(upper.tri.Y_ij))
for(t in 1:num_samples){
z_chain_mat = vec2mat_0_P(z_i[,t], theta[,,t])
P_entry = inverse_logit_f(theta[,,t])
P_ij = calculate_victory_probabilities(z_mat =z_chain_mat, P = P_entry)
llik[t,] =  dbinom(upper.tri.Y_ij, upper.tri.N_ij, P_ij[filtering_obs],log = T)
Y_pred[t,] <- rbinom(length(upper.tri.Y_ij), upper.tri.N_ij,
P_ij[filtering_obs])
}
r_effs = loo::relative_eff(llik,rep(1,num_samples))
loo_model_fit = loo::loo(llik,cores = 3,save_psis = T,r_eff = r_effs)
df_model_choice = rbind(df_model_choice, data.frame(K_true = uploaded_results[[i]]$ground_truth$K,
true_model = uploaded_results[[i]]$ground_truth$model,
est_model = uploaded_results[[i]]$control_containers$est_model,
K_est = dim(theta)[1],
looic =loo_model_fit$looic))
}
}
df_model_choice%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point()+
labs(title = "Looic for different models",
subtitle = 'Lower values are better',
caption = paste0("True data ~ ",df_model_choice$true_model[1], " model ,K = ",df_model_choice$K_true[1]))
which.min(df_model_choice$looic)
df_model_choice[which.min(df_model_choice$looic),]
df_model_choice%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point()+
geom_point(data=df_model_choice[which.min(df_model_choice$looic),],aes(x = K_est, y=looic, color'red'))
labs(title = "Looic for different models",
subtitle = 'Lower values are better',
caption = paste0("True data ~ ",df_model_choice$true_model[1], " model ,K = ",df_model_choice$K_true[1]))
df_model_choice%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point()+
geom_point(data=df_model_choice[which.min(df_model_choice$looic),],aes(x = K_est, y=looic, color'red'))+
df_model_choice%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point()+
geom_point(data=df_model_choice[which.min(df_model_choice$looic),],aes(x = K_est, y=looic), color='red')+
labs(title = "Looic for different models",
subtitle = 'Lower values are better',
caption = paste0("True data ~ ",df_model_choice$true_model[1], " model ,K = ",df_model_choice$K_true[1]))
df_model_choice%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point(data=df_model_choice[which.min(df_model_choice$looic),],aes(x = K_est, y=looic), color='red')+
geom_point()+
labs(title = "Looic for different models",
subtitle = 'Lower values are better',
caption = paste0("True data ~ ",df_model_choice$true_model[1], " model ,K = ",df_model_choice$K_true[1]))
df_model_choice%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point()+
geom_point(data=df_model_choice[which.min(df_model_choice$looic),],aes(x = K_est, y=looic), color='red',show.legend = F)+
labs(title = "Looic for different models",
subtitle = 'Lower values are better',
caption = paste0("True data ~ ",df_model_choice$true_model[1], " model ,K = ",df_model_choice$K_true[1]))
df_model_choice%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point()+
geom_point(data=df_model_choice[which.min(df_model_choice$looic),],aes(x = K_est, y=looic), color='violet',show.legend = F)+
labs(title = "Looic for different models",
subtitle = 'Lower values are better',
caption = paste0("True data ~ ",df_model_choice$true_model[1], " model ,K = ",df_model_choice$K_true[1]))
df_model_choice%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point()+
labs(title = "Looic for different models",
subtitle = 'Lower values are better',
caption = paste0("True data ~ ",df_model_choice$true_model[1], " model ,K = ",df_model_choice$K_true[1]))
source("~/.active-rstudio-document", echo=TRUE)
print(df_model_choice[which.min(df_model_choice$looic),])
source("~/.active-rstudio-document", echo=TRUE)
