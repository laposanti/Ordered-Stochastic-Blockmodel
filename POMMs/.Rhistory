P_est_relabeled<- inverse_logit_f(P_s_table$P_hat)
#some traceplots
upper_tri_indices= which(upper.tri(P_est_relabeled, diag=T),arr.ind = T)
if(is.simulation ==T){
theta_trace_df_post_switch <- do.call(rbind, lapply(1:(N_iter-burnin), function(j) {
data.frame(iteration = j,
theta = upper.tri.extractor(theta_chain_permuted[,,j]),
theta_true = upper.tri.extractor(uploaded_results$chain1$ground_truth$theta),
entry = paste0(upper_tri_indices[,1], upper_tri_indices[,2]))
}))
theta_trace_df_post_switch= theta_trace_df_post_switch%>%
mutate(P = inverse_logit_f(theta))%>%
mutate(P_true = inverse_logit_f(theta_true))
traceplot_P = ggplot(theta_trace_df_post_switch, aes(x = iteration, color = entry, group=entry))+
geom_line(aes(y=P), alpha=.3)+
geom_line(aes(y=P_true), linetype=2, color='red')+
facet_wrap(~entry)+
theme_bw()
}else if(is.simulation ==F){
P_trace_df_post_switch <- do.call(rbind, lapply(1:(N_iter-burnin), function(j) {
data.frame(iteration = j+burnin,
theta = upper.tri.extractor(theta_chain_permuted[,,j]),
entry = paste0(upper_tri_indices[,1], upper_tri_indices[,2]))
}))
P_trace_df_post_switch=P_trace_df_post_switch%>% mutate(P = inverse_logit_f(theta))
traceplot_P = ggplot(P_trace_df_post_switch, aes(x = iteration, color = entry, group=entry))+
geom_line(aes(y=P), alpha=.3)+
facet_wrap(~entry)+
theme_bw()
}
plot_name_traceplot_P <- paste0(processed_wd,"//P_traceplot",true_model,est_model,"K",K,"_N",nrow(uploaded_results$chain1$Y_ij),".png")
png(plot_name_traceplot_P,width = 800, height = 800)
par(mar = c(1.5, 1.5,1.5,1.5))
print(traceplot_P)
dev.off()
if(is.simulation==T){
P_s_table_sum <- P_s_table_save%>%
summarise(
average_credible_length = mean(abs(quantile95 - quantile05)),
MAE = mean(MAE)
) %>% round(3)
}else{
P_s_table_sum <- P_s_table_save%>%
summarise(
average_credible_length = mean(abs(quantile95 - quantile05))
) %>% round(3)
}
P_s_table_sum = P_s_table_sum %>% mutate(model = est_model)%>% mutate(n_clust = K)
#adjusting colnames for the current number of clusters K
if(!exists('Pcontainer')){
Pcontainer = P_s_table_sum
}else{
Pcontainer =  rbind(Pcontainer,P_s_table_sum)
}
#-------------------------------------------------------------------------------
# relabeling the chains to correct for label switching
#-------------------------------------------------------------------------------
# Relabel remaining chains
z_burned_1 = uploaded_results$chain1$est_containers$z[,-c(1:burnin)]
z_burned_2 = uploaded_results$chain2$est_containers$z[,-c(1:burnin)]
z_burned_3 = uploaded_results$chain3$est_containers$z[,-c(1:burnin)]
z_burned_4 = uploaded_results$chain4$est_containers$z[,-c(1:burnin)]
theta_burned_1 = uploaded_results$chain1$est_containers$theta[,,-c(1:burnin)]
theta_burned_2 = uploaded_results$chain2$est_containers$theta[,,-c(1:burnin)]
theta_burned_3 = uploaded_results$chain3$est_containers$theta[,,-c(1:burnin)]
theta_burned_4 = uploaded_results$chain4$est_containers$theta[,,-c(1:burnin)]
z_burned_list = list(z_burned_1,
z_burned_2,
z_burned_3,
z_burned_4)
theta_burned_list = list(theta_burned_1,
theta_burned_2,
theta_burned_3,
theta_burned_4)
num_samples = N_iter
filtering_obs = which(upper.tri(N_ij) & N_ij!= 0,arr.ind = T)
upper.tri.Y_ij = Y_ij[filtering_obs]
upper.tri.N_ij = N_ij[filtering_obs]
Y_pred = matrix(NA, nrow = num_samples,ncol = length(upper.tri.Y_ij))
LL_list <- foreach(i=1:4, .packages='foreach')%do%{
z_chain <- z_burned_list[[i]]
theta_chain <- theta_burned_list[[i]]
llik = matrix(NA,  nrow = num_samples, ncol = length(upper.tri.Y_ij))
for(t in 1:num_samples){
z_chain_mat = vec2mat_0_P(z_chain[,t], theta_burned[,,1])
P_entry = inverse_logit_f(theta_chain[,,t])
P_ij = calculate_victory_probabilities(z_mat =z_chain_mat, P = P_entry)
llik[t,] =  dbinom(upper.tri.Y_ij, upper.tri.N_ij, P_ij[filtering_obs],log = T)
Y_pred[t,] <- rbinom(length(upper.tri.Y_ij), upper.tri.N_ij,
P_ij[filtering_obs])
}
print(i)
return(llik)
}
LLik_sum <- lapply(LL_list,FUN = rowSums)
#-------------------------------------------------------------------------------
# printing traceplots of the likelihood
#-------------------------------------------------------------------------------
df_traceplot = data.frame(chain = c(rep(1,num_samples), rep(2,num_samples), rep(3,num_samples),rep(4,num_samples)),
log_likelihood = c(LLik_sum[[1]],LLik_sum[[2]],LLik_sum[[3]],LLik_sum[[4]]),
iterations = rep(1:num_samples,4))
df_traceplot = df_traceplot %>% mutate(chain = factor(chain,
levels = 1:4))
# Plot the density lines
stationary_density =  df_traceplot %>%
ggplot(aes(y = log_likelihood, color = chain), alpha=0.5) + # Set 'x' to log_likelihood
geom_density() +
labs(title = "Stationary density for the 4 chains",
subtitle = paste0("Number of iterations: ",
N_iter," || Burnin: ", burnin),
x = 'Density',
y = "log-likelihood sum",
color = "Chain",
caption = paste0("True data: ", true_model,
", Fitted model: ", est_model, ", K = ", K))+ # Add a label for the legend
theme_minimal() + # Use a minimal theme for better appearance
theme(legend.position = "right") # Position the legend to the right
stationary_name <- paste0(processed_wd,"//stationary_density",est_model, "_K",K,"_N",nrow(uploaded_results$chain1$Y_ij),".png")
png(stationary_name,width = 500, height = 250)
print(stationary_density)
dev.off()
my_sexy_traceplot<- ggplot(df_traceplot,
aes(x = iterations,
y = log_likelihood,
color = factor(chain),
group=chain))+
geom_line(alpha = .45)+
labs(title = "Log likelihood for the 4 chains",
subtitle = paste0("Number of iterations: ",
N_iter," || Burnin: ", burnin),
x = "Iterations",
y = "Log likelihood",
color = "Chain",
caption = paste0("True data: ", true_model,
", Fitted model: ", est_model, ", K = ", K))+
theme_bw()
traceplot_name <- paste0(processed_wd,"//traceplot",est_model, "_K",K,"_N",nrow(uploaded_results$chain1$Y_ij),".png")
png(traceplot_name,width = 500, height = 250)
print(my_sexy_traceplot)
dev.off()
library(bayesplot)
r_effs = loo::relative_eff(LL_list[[1]],rep(1,num_samples))
loo_model_fit = loo(LL_list[[1]],cores = 3,save_psis = T,r_eff = r_effs)
r_effs = loo::relative_eff(LL_list[[1]],rep(1,num_samples))
LL_list[[1]]
num_samples
num_samples = N_iter
filtering_obs = which(upper.tri(N_ij) & N_ij!= 0,arr.ind = T)
upper.tri.Y_ij = Y_ij[filtering_obs]
upper.tri.N_ij = N_ij[filtering_obs]
Y_pred = matrix(NA, nrow = num_samples,ncol = length(upper.tri.Y_ij))
LL_list <- foreach(i=1:4, .packages='foreach')%do%{
z_chain <- z_burned_list[[i]]
theta_chain <- theta_burned_list[[i]]
llik = matrix(NA,  nrow = num_samples, ncol = length(upper.tri.Y_ij))
for(t in 1:num_samples){
z_chain_mat = vec2mat_0_P(z_chain[,t], theta_burned[,,1])
P_entry = inverse_logit_f(theta_chain[,,t])
P_ij = calculate_victory_probabilities(z_mat =z_chain_mat, P = P_entry)
llik[t,] =  dbinom(upper.tri.Y_ij, upper.tri.N_ij, P_ij[filtering_obs],log = T)
Y_pred[t,] <- rbinom(length(upper.tri.Y_ij), upper.tri.N_ij,
P_ij[filtering_obs])
}
print(i)
return(llik)
}
LLik_sum <- lapply(LL_list,FUN = rowSums)
LLik_sum[[1]][N_iter]
num_samples
N_iter
LLik_sum[[1]][1332]
num_samples = 1332
filtering_obs = which(upper.tri(N_ij) & N_ij!= 0,arr.ind = T)
upper.tri.Y_ij = Y_ij[filtering_obs]
upper.tri.N_ij = N_ij[filtering_obs]
Y_pred = matrix(NA, nrow = num_samples,ncol = length(upper.tri.Y_ij))
LL_list <- foreach(i=1:4, .packages='foreach')%do%{
z_chain <- z_burned_list[[i]]
theta_chain <- theta_burned_list[[i]]
llik = matrix(NA,  nrow = num_samples, ncol = length(upper.tri.Y_ij))
for(t in 1:num_samples){
z_chain_mat = vec2mat_0_P(z_chain[,t], theta_burned[,,1])
P_entry = inverse_logit_f(theta_chain[,,t])
P_ij = calculate_victory_probabilities(z_mat =z_chain_mat, P = P_entry)
llik[t,] =  dbinom(upper.tri.Y_ij, upper.tri.N_ij, P_ij[filtering_obs],log = T)
Y_pred[t,] <- rbinom(length(upper.tri.Y_ij), upper.tri.N_ij,
P_ij[filtering_obs])
}
print(i)
return(llik)
}
LLik_sum <- lapply(LL_list,FUN = rowSums)
#-------------------------------------------------------------------------------
# printing traceplots of the likelihood
#-------------------------------------------------------------------------------
df_traceplot = data.frame(chain = c(rep(1,num_samples), rep(2,num_samples), rep(3,num_samples),rep(4,num_samples)),
log_likelihood = c(LLik_sum[[1]],LLik_sum[[2]],LLik_sum[[3]],LLik_sum[[4]]),
iterations = rep(1:num_samples,4))
df_traceplot = df_traceplot %>% mutate(chain = factor(chain,
levels = 1:4))
# Plot the density lines
stationary_density =  df_traceplot %>%
ggplot(aes(y = log_likelihood, color = chain), alpha=0.5) + # Set 'x' to log_likelihood
geom_density() +
labs(title = "Stationary density for the 4 chains",
subtitle = paste0("Number of iterations: ",
N_iter," || Burnin: ", burnin),
x = 'Density',
y = "log-likelihood sum",
color = "Chain",
caption = paste0("True data: ", true_model,
", Fitted model: ", est_model, ", K = ", K))+ # Add a label for the legend
theme_minimal() + # Use a minimal theme for better appearance
theme(legend.position = "right") # Position the legend to the right
stationary_name <- paste0(processed_wd,"//stationary_density",est_model, "_K",K,"_N",nrow(uploaded_results$chain1$Y_ij),".png")
png(stationary_name,width = 500, height = 250)
print(stationary_density)
dev.off()
my_sexy_traceplot<- ggplot(df_traceplot,
aes(x = iterations,
y = log_likelihood,
color = factor(chain),
group=chain))+
geom_line(alpha = .45)+
labs(title = "Log likelihood for the 4 chains",
subtitle = paste0("Number of iterations: ",
N_iter," || Burnin: ", burnin),
x = "Iterations",
y = "Log likelihood",
color = "Chain",
caption = paste0("True data: ", true_model,
", Fitted model: ", est_model, ", K = ", K))+
theme_bw()
traceplot_name <- paste0(processed_wd,"//traceplot",est_model, "_K",K,"_N",nrow(uploaded_results$chain1$Y_ij),".png")
png(traceplot_name,width = 500, height = 250)
print(my_sexy_traceplot)
dev.off()
library(bayesplot)
r_effs = loo::relative_eff(LL_list[[1]],rep(1,num_samples))
loo_model_fit = loo(LL_list[[1]],cores = 3,save_psis = T,r_eff = r_effs)
saveRDS(loo_model_fit, paste0(processed_wd,"/modelcheck",est_model,K,".RDS"))
plot(loo_model_fit)
waic_model_fit = waic(LL_list[[1]])
problematic_values = pareto_k_ids(loo_model_fit)
prob_df = data.frame(row = rownames(Y_ij)[row(Y_ij)[problematic_values]],
col = colnames(Y_ij)[col(Y_ij)[problematic_values]])
for(i in 1:length(prob_df)){
prob_df$z_row[i] =  point_est_z[which(rownames(Y_ij)==prob_df$row[i])]
prob_df$z_col[i] =  point_est_z[which(rownames(Y_ij)==prob_df$col[i])]
}
for(i in 1:length(prob_df)){
prob_df$P_MCMC[i] =  P_est[prob_df$z_row[i],prob_df$z_col[i]]
prob_df$P_hat[i] =  Y_ij[prob_df$row[i],prob_df$col[i]]/N_ij[prob_df$row[i],prob_df$col[i]]
}
pareto_k_values(loo_model_fit)
#
#
# upper.tri.Y_ij[which(bad_values == Inf)] > upper.tri.N_ij[which(bad_values == Inf)]
# upper.tri.Y_ij[is.na(bad_values)] > upper.tri.N_ij[is.na(bad_values)]
#
# dbinom(upper.tri.Y_ij[which(bad_values == Inf)] , upper.tri.N_ij[which(bad_values == Inf)], P_ij[which(bad_values == Inf)], log = T)
# dbinom(upper.tri.Y_ij[is.na(bad_values)] , upper.tri.N_ij[is.na(bad_values)], P_ij[is.na(bad_values)], log = T)
#
# dbinom(upper.tri.Y_ij[961] , upper.tri.N_ij[961], P_ij[961], log = T)
#
diagnostic1<- ppc_loo_pit_qq(
y = upper.tri.Y_ij,
yrep = Y_pred,
lw = weights(loo_model_fit$psis_object)
)+
labs(x = 'uniform',title = paste0('Posterior Predictive LOO-PIT'),
subtitle = paste0('Model =',est_model,", K=",K),
caption = paste0("data source:",true_model))
ggsave(plot=diagnostic1,filename = paste0(processed_wd,'diagnostic1',est_model,K,".png"))
diagnostic1
diagnostic2 = ppc_loo_pit_overlay( y = upper.tri.Y_ij,
yrep = Y_pred,
lw = weights(loo_model_fit$psis_object))+
labs(x = 'uniform',title = paste0('Posterior Predictive LOO-PIT'),
subtitle = paste0('Model =',est_model,", K=",K),
caption = paste0("data source:",true_model))
ggsave(plot=diagnostic2,filename = paste0(processed_wd,'diagnostic2',est_model,K,".png"))
diagnostic2
source("~/Desktop/Nial/POMM_pairwise/POMMs/model_auxiliary_functions/reading_resultS.R", echo=TRUE)
source("~/Desktop/Nial/POMM_pairwise/POMMs/model_auxiliary_functions/reading_resultS.R", echo=TRUE)
to_be_saved = (burnin+1):N_iter
N_iter_eff = sum(to_be_saved %% thin == 0)
seed=20
N_iter <- 500 #number of iterations
burnin <- 300 #number of discarded iterations
thin=15
# for(K in 3:10){
K = data_to_be_estimated$ground_truth$K
K_est = rep(K, n_chains) #number of clusters to fit
is.simulation=T
#where to save the data
saving_directory = "./Results/"
#Boolean: power_posterior_approach = T estimates the marginal likelihood via power posteriors
power_posterior_apprach = F
custom_init <- NA
print(paste0("Estimation of the SST model, K=", K_est))
print(paste0("Begin cycle at:", date(), "\n"))
estimation_control <- list(z = 1, sigma_squared = 0, mu_vec = 1 ,K = 0, theta = 0)
chains_SST <- adaptive_MCMC_orderstats_powerposterior(Y_ij = Y_ij, N_ij = N_ij,
saving_directory = saving_directory,
estimation_control = estimation_control,
burnin = burnin,
ground_truth = ground_truth,
n = n, N_iter = N_iter,
K_est = K_est,data_description = data_description,
seed = seed,
model = est_model,
custom_init = custom_init,
power_posterior_apprach = power_posterior_apprach,
thin=thin)
source("./model_auxiliary_functions/Functions_priorSST.R")
source("./Metropolis_within_Gibbs_code_powerposterior.R")
source("./model_auxiliary_functions/MCMC_functions.R")
subject = "lapo.santi@ucdconnect.ie"
chains_SST <- adaptive_MCMC_orderstats_powerposterior(Y_ij = Y_ij, N_ij = N_ij,
saving_directory = saving_directory,
estimation_control = estimation_control,
burnin = burnin,
ground_truth = ground_truth,
n = n, N_iter = N_iter,
K_est = K_est,data_description = data_description,
seed = seed,
model = est_model,
custom_init = custom_init,
power_posterior_apprach = power_posterior_apprach,
thin=thin)
data_to_be_estimated = readRDS(paste0(data_directory,filenames[file]))
setwd("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/")
source("./model_auxiliary_functions/Functions_priorSST.R")
source("./Metropolis_within_Gibbs_code_powerposterior.R")
source("./model_auxiliary_functions/MCMC_functions.R")
subject = "lapo.santi@ucdconnect.ie"
service_account_key = "./sonic-426715-75af23aca274.json"
googledrive::drive_deauth()
googledrive::drive_auth_configure(path = "./client_secret_573831164304-jqqj3i5mhvubbkkuifvtgkfsut8lse3g.apps.googleusercontent.com.json")
googledrive::drive_auth(email = subject)
#
#
# 2
# # Get the folder (if you already have it) or specify the path where you want to upload
folder_url <- "https://drive.google.com/drive/u/1/folders/1p3AUy241bkANcZskowWgc14QqqVmderu"
folder <- drive_get(as_id(folder_url))
print('Simulation study for fixed K, for K=3,4,5,6')
is.simulation=T
data_directory = "./Data/Sim1_data/"
filenames <- list.files(pattern = true_model,path =data_directory)
print(filenames) #data to be estimated
choose_model_to_estimate = c('SST', 'WST', 'Simple')
for(file in 1:length(filenames)){
data_to_be_estimated = readRDS(paste0(data_directory,filenames[file]))
stopifnot(data_to_be_estimated$model == true_model)
recovery_capability = data_to_be_estimated$recovery_capability
N_ij = data_to_be_estimated$N_ij
n = nrow(N_ij)
Y_ij = data_to_be_estimated$Y_ij
ground_truth =data_to_be_estimated$ground_truth
K= nrow(data_to_be_estimated$ground_truth$theta)
data_description = paste0(true_model,K)
print(paste0("True data--->", filenames[file]))
##############################################################################
# Estimation: set the parameters of the estimation
##############################################################################
n_chains = 4
optimal_acceptance_rate_theta =.44
optimal_acceptance_rate_mu = .234
seed=20
N_iter <- 500 #number of iterations
burnin <- 300 #number of discarded iterations
thin=15
# for(K in 3:10){
K = data_to_be_estimated$ground_truth$K
K_est = rep(K, n_chains) #number of clusters to fit
is.simulation=T
print(paste0("True data--->", filenames[file], "\n"))
#-----------------------------------------------------------------------------
# SST MODEL
#-----------------------------------------------------------------------------
if('SST' %in% choose_model_to_estimate){
print(paste0("Estimation of the SST model, K=",K))
print(paste0("Begin cycle at:", date()))
est_model = 'SST'
#setting up the chain hyperparameter
#where to save the data
saving_directory = "./Results/"
#Boolean: power_posterior_approach = T estimates the marginal likelihood via power posteriors
power_posterior_apprach = F
custom_init <- NA
print(paste0("Estimation of the SST model, K=", K_est))
print(paste0("Begin cycle at:", date(), "\n"))
estimation_control <- list(z = 1, sigma_squared = 0, mu_vec = 1 ,K = 0, theta = 0)
chains_SST <- adaptive_MCMC_orderstats_powerposterior(Y_ij = Y_ij, N_ij = N_ij,
saving_directory = saving_directory,
estimation_control = estimation_control,
burnin = burnin,
ground_truth = ground_truth,
n = n, N_iter = N_iter,
K_est = K_est,data_description = data_description,
seed = seed,
model = est_model,
custom_init = custom_init,
power_posterior_apprach = power_posterior_apprach,
thin=thin)
my_names <- paste0("chain", 1:n_chains)
names(chains_SST)<- my_names
chains_SST[['recovery_level']] = recovery_capability
my_filename = paste0('./Results/MCMC_output/Fixed_K/Simulation/Data_from',data_description, "_est_model",
est_model,"_Kest",K_est[[1]],
'recovery_level',recovery_capability,'.rds')
saveRDS(object = chains_SST, file = my_filename)
drive_put(media = my_filename, path = folder)
#
#
}
#-----------------------------------------------------------------------------
# WST MODEL
#-----------------------------------------------------------------------------
if('WST' %in% choose_model_to_estimate){
print(paste0("Estimation of the WST model, K=",K))
print(paste0("Begin cycle at:",date()))
#initializing each chain
est_model = 'WST'
#setting up the chain hyperparameter
#where to save the data
saving_directory = "./Results/"
#Boolean: power_posterior_approach = T estimates the marginal likelihood via power posteriors
power_posterior_apprach = F
custom_init <- NA
print(paste0("Estimation of the WST model, K=", K_est))
print(paste0("Begin cycle at:", date(), "\n"))
estimation_control <- list(z = 1, sigma_squared = 0, mu_vec = 0 ,K = 0, theta = 1)
chains_WST <- adaptive_MCMC_orderstats_powerposterior(Y_ij = Y_ij, N_ij = N_ij,
saving_directory = saving_directory,
estimation_control = estimation_control,
burnin = burnin,
ground_truth = ground_truth,
n = n, N_iter = N_iter,
K_est = K_est,data_description = data_description,
seed = seed,
model = est_model,
custom_init = custom_init,
power_posterior_apprach = power_posterior_apprach,thin = thin)
my_names <- paste0("chain", 1:n_chains)
names(chains_WST)<-my_names
chains_WST[['recovery_level']] = recovery_capability
my_filename = paste0('./Results/MCMC_output/Fixed_K/Simulation/Data_from',
data_description, "_est_model",
est_model,"_Kest",K_est[[1]],
'recovery_level',recovery_capability,'.rds')
saveRDS(object = chains_WST, file = my_filename)
drive_put(media = my_filename, path = folder)
}
#-----------------------------------------------------------------------------
# Simple model
#-----------------------------------------------------------------------------
if('Simple' %in% choose_model_to_estimate){
print(paste0("Estimation of Simple model, K=",K))
print(paste0("Begin cycle at:",date()))
est_model = 'Simple'
#setting up the chain hyperparameter
#where to save the data
saving_directory = "./Results/"
#Boolean: power_posterior_approach = T estimates the marginal likelihood via power posteriors
power_posterior_apprach = F
custom_init <- NA
estimation_control = list(z = 1,sigma_squared=0, mu_vec=0,K=0,theta=1)
chains_Simple = adaptive_MCMC_orderstats_powerposterior(Y_ij = Y_ij, N_ij = N_ij,
saving_directory = saving_directory,
estimation_control = estimation_control,
burnin = burnin,
ground_truth = ground_truth,
n = n, N_iter = N_iter,
K_est = K_est,data_description = data_description,
seed = seed,
model = est_model,
custom_init = custom_init,
power_posterior_apprach = power_posterior_apprach,
thin=thin)
my_names <- paste0("chain", 1:n_chains)
names(chains_Simple)<- my_names
chains_Simple[['recovery_level']] = recovery_capability
my_filename = paste0('./Results/MCMC_output/Fixed_K/Simulation/Data_from',
data_description, "_est_model",
est_model,"_Kest",K_est[[1]],
'recovery_level',recovery_capability,'.rds')
saveRDS(object = chains_Simple, file = my_filename)
drive_put(media = my_filename, path = folder)
}
}
chains_SST$chain1$est_containers$z[,-1]
source("./model_auxiliary_functions/Functions_priorSST.R")
source("./Metropolis_within_Gibbs_code_powerposterior.R")
source("./model_auxiliary_functions/MCMC_functions.R")
chains_SST <- adaptive_MCMC_orderstats_powerposterior(Y_ij = Y_ij, N_ij = N_ij,
saving_directory = saving_directory,
estimation_control = estimation_control,
burnin = burnin,
ground_truth = ground_truth,
n = n, N_iter = N_iter,
K_est = K_est,data_description = data_description,
seed = seed,
model = est_model,
custom_init = custom_init,
power_posterior_apprach = power_posterior_apprach,
thin=thin)
my_names <- paste0("chain", 1:n_chains)
names(chains_SST)<- my_names
chains_SST$chain1$est_containers$z[,-1]
