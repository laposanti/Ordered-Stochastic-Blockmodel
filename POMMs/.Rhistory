mutate(unique_identifier = unique_identifier+est_cl)%>%
mutate(relative_victories = marginal_victories/(marginal_losses+marginal_victories))
if(est_model =='Simple'){
new_order = est_df %>%
group_by(est_cl)%>%
summarise(mean_win = mean(relative_victories))%>%
arrange(-mean_win)
# Example new order (a permutation of 1:K)
new_z = vector()
for(item in 1:n){
new_z = append(new_z,which(new_order$est_cl == point_est_z[item]))
}
est_df$est_cl = new_z
write.csv(new_z, paste0(processed_wd,"/z_est_K_",K,"model",est_model,".csv"))
}
combined_df = players_df %>% inner_join(est_df, by = 'Id')%>% dplyr::arrange(unique_identifier)
if(true_model=='Tennis_data'){
degree_plot <- ggplot(combined_df, aes(x = reorder(Id, -relative_victories), y = relative_victories, fill =factor(est_cl) )) +
geom_bar(stat = "identity") +
labs(x = "Player Name", y = "Percentage Victories", fill='Cluster', title = "Percentage of victories for each player",
subtitle = 'Players are sorted according to their victory %') +
scale_color_discrete(name = "Cluster") +
theme_bw() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1, size = 5),
text = element_text(size = 10, family = "Arial"),
plot.title = element_text(size = 13, face = "bold", margin = margin(r = 10)),
plot.subtitle = element_text(size = 10, margin = margin(t = 10, r = 10, b = 10)),  # Adjust the top margin
plot.margin = margin(20, 20, 20, 20)
)
}else if(true_model == 'Citation_data'){
degree_plot <- ggplot(combined_df, aes(x = reorder(Id, median_rank), y = relative_victories, fill =factor(est_cl) )) +
geom_bar(stat = "identity") +
labs(x = "Journal Name", y = "Citations received / Citations made", fill='Cluster',
title = "Citations received / citations made for each journal",
subtitle = 'Players are ranked by the Stigler model of Varin et al (2016)') +
scale_color_discrete(name = "Cluster") +
theme_bw() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1, size = 5),
text = element_text(size = 10, family = "Arial"),
plot.title = element_text(size = 13, face = "bold", margin = margin(r = 10)),
plot.subtitle = element_text(size = 10, margin = margin(t = 10, r = 10, b = 10)),  # Adjust the top margin
plot.margin = margin(20, 20, 20, 20)
)
}
png(plot_name,width = 800, height = 627)
print(degree_plot)
dev.off()
#
#---------------------------------------------------------------------------
# CHECKING THE HOMOGENEITY OF THE CLUSTERS: HEATMAP
#---------------------------------------------------------------------------
ggplot(combined_df, aes(x=relative_victories, y=last_rank)) +
# Add points
geom_point(color = "blue", size = 2) +
# Add a red dotted line at 45 degrees passing through the origin
geom_smooth(method = "lm", color = "green", se = FALSE, linetype = "solid", size = 1) +
# Add title and labels
ggtitle("Scatter Plot of Relative Victories vs Median Rank") +
xlab("Relative Victories %") +
ylab("Median ATP Rank") +
scale_x_continuous(labels = scales::percent) +
# Improve the overall appearance
theme_minimal() +
scale_y_reverse()+
theme(
plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10),
panel.grid.major = element_line(color = "grey", linetype = "dotted"),
panel.grid.minor = element_blank()
)
plot_name <- paste0(processed_wd,"//RankvsClust_Est_model",est_model, "_K",K,"_N",nrow(uploaded_results$chain1$Y_ij),".png")
colnames(Y_ij) <- rownames(Y_ij)
for(i in seq_len(nrow(z_df_complete))){
z_df_complete$marginal_victories_row[i] <- sum(Y_ij[z_df_complete$row[i],]/est_df$unique_identifier,na.rm = T)/sum(Y_ij[,z_df_complete$row[i]]*est_df$unique_identifier,na.rm = T)
}
for(i in seq_len(nrow(z_df_complete))){
z_df_complete$marginal_victories_col[i] <- sum(Y_ij[z_df_complete$col[i],]/est_df$unique_identifier,na.rm = T)/sum(Y_ij[,z_df_complete$col[i]]*est_df$unique_identifier,na.rm = T)
}
plot_df = z_df_complete%>%
inner_join(est_df, by = c("row" = "Id")) %>%
dplyr::rename(row_z = est_cl) %>%
inner_join(est_df, by = c("col" = "Id")) %>%
dplyr::rename(col_z = est_cl) %>%
mutate(row = factor(row, levels = unique(row[order(row_z, -marginal_victories_row, decreasing = TRUE)])),
col = factor(col, levels = unique(col[order(col_z, -marginal_victories_col, decreasing = F)]))) %>%
mutate(perc_success = Y/N)
v_lines_list = list()
for(k in 1:(K-1)){
lines_df = plot_df %>% filter(col_z == k, row_z == k)
v_lines_list[[k]] <- lines_df$row[which.min(lines_df$marginal_victories_row)]
}
est_df_disordered = est_df %>% mutate(est_cl =order(Id))
plot_df_disordered = z_df_complete%>%
inner_join(est_df_disordered, by = c("col" = "Id")) %>%
inner_join(est_df_disordered, by = c("row" = "Id")) %>%
mutate(perc_success = Y/N) %>%
mutate(col = factor(col, levels = unique(col[order(est_cl.x, col)])),
row = factor(row, levels = unique(row[order(est_cl.y , row, decreasing = TRUE)])))
rowSums(Y_ij)
if(true_model == 'Tennis_data'){
adjacency_m   <- ggplot(plot_df, aes(x = col, y = row)) +
geom_tile(aes(fill = perc_success), color = "gray", show.legend = T) +
scale_fill_gradient(low = "white", high = "red") +
geom_ysidecol(aes(x = degree_pl_row, color=factor(row_z))) +
geom_vline(xintercept = unlist(v_lines_list), color='black')+
geom_hline(yintercept = unlist(v_lines_list), color='black')+
labs(x = paste0("Players ordered by blocks"),
y = paste0("Playersordered by blocks"),
fill = "% victories",
color = "Block")+
theme(legend.position = 'bottom', legend.direction = 'horizontal')+
theme_bw() +
theme(axis.text.y = element_blank(),
axis.text.x = element_blank(),
axis.title.x = element_blank(),
axis.title.y = element_blank())
adjacency_m_disordered<- ggplot(plot_df_disordered, aes(x = col, y = row)) +
geom_tile(aes(fill = perc_success), color = "gray", show.legend = F) +
scale_fill_gradient(low = "white", high = "red") +
labs(x = paste0("Players ordered by blocks"),
y = paste0("Players ordered by blocks"),
fill = "% relative citations",
color = "Block")+
theme(legend.position = 'bottom', legend.direction = 'horizontal')+
theme_bw() +
theme(axis.text.y = element_blank(),
axis.title.x = element_blank(),
axis.text.x = element_blank(),
axis.title.y = element_blank())
# Assuming adjacency_m and adjacency_m_disordered are your two ggplot objects
# Combine the plots
# Extract the legend from the first plot
legend <- get_legend(adjacency_m)
# Combine the plot without the legend and the extracted legend
combined_plot_with_legend <- plot_grid(adjacency_m + theme(legend.position = "none"),
legend,
rel_widths = c(1, 0.2))
# Now combine with the second plot
final_combined_plot <- plot_grid(adjacency_m_disordered, combined_plot_with_legend,
ncol = 2, labels = 'auto',
rel_widths = c(0.75, 1))
#saving the heatmap
plot_name1<- paste0(processed_wd,"//OrderedVsUnordered",est_model, "_K",K,"_N",nrow(uploaded_results$chain1$Y_ij),".png")
png(plot_name1,width = 900, height = 450)
print(final_combined_plot)
dev.off()
}else if(true_model == 'Citation_data'){
adjacency_m   <- ggplot(plot_df, aes(x = col, y = row)) +
geom_tile(aes(fill = perc_success), color = "gray", show.legend = T) +
scale_fill_gradient(low = "white", high = "red") +
geom_ysidecol(aes(x = degree_pl_row, color=factor(row_z))) +
geom_vline(xintercept = unlist(v_lines_list), color='black')+
geom_hline(yintercept = unlist(v_lines_list), color='black')+
labs(x = paste0("Journals ordered by blocks"),
y = paste0("Journals ordered by blocks"),
fill = "% cit. received/made",
color = "Block")+
theme(legend.position = 'bottom', legend.direction = 'horizontal')+
theme_bw()+
theme(axis.text.y = element_blank(),
axis.text.x = element_blank(),
axis.title.x = element_blank(),
axis.title.y = element_blank())
if(est_model == 'SST'&file==4){
adjacency_m_disordered<- ggplot(plot_df_disordered, aes(x = col, y = row)) +
geom_tile(aes(fill = perc_success), color = "gray", show.legend = F) +
scale_fill_gradient(low = "white", high = "red") +
labs(x = paste0("Journals ordered by blocks"),
y = paste0("Journals ordered by blocks"),
fill = "% citations received/made",
color = "Block")+
theme(legend.position = 'bottom', legend.direction = 'horizontal')+
theme_bw() +
theme(axis.text.y = element_blank(),
axis.text.x = element_blank(),
axis.title.x = element_blank(),
axis.title.y = element_blank())
# Assuming adjacency_m and adjacency_m_disordered are your two ggplot objects
# Combine the plots
# Extract the legend from the first plot
legend <- get_legend(adjacency_m)
# Now combine with the second plot
final_combined_plot <- plot_grid(adjacency_m_disordered, adjacency_m + guides(color = FALSE, fill = FALSE),
legend,
ncol = 3,rel_widths = c(1,1.2,0.5))
#saving the heatmap
plot_name1<- paste0(processed_wd,"//cowplot_plot",est_model, "_K",K,"_N",nrow(uploaded_results$chain1$Y_ij),".png")
png(plot_name1,width = 1100, height = 428)
print(final_combined_plot)
dev.off()
}
}
#saving the heatmap
plot_name1<- paste0(processed_wd,"//Combined_plot",est_model, "_K",K,"_N",nrow(uploaded_results$chain1$Y_ij),".png")
png(plot_name1,width = 800, height = 594)
print(adjacency_m)
dev.off()
#---------------------------------------------------------------------------
# CHECKING THE RANKING and THE CLUSTERING
#---------------------------------------------------------------------------
percentage_to_display <- 10
set.seed(23)
# Randomly sample a subset of labels to display
if(true_model == 'Citation_data'){
rank_boxplot<- ggplot(combined_df, aes(x = factor(est_cl), y = median_rank,color = factor(est_cl))) +
geom_boxplot(aes(fill=factor(est_cl)),alpha=.3) +
geom_label_repel(
data = combined_df,  # Use the sampled labels for display
aes(label = Id),
size = 3,
hjust = .5,
vjust = 0,
show.legend = F,
alpha=.8
) +
labs(title= "Rank of the players divided into blocks",
subtitle = "Not all names are displayed to avoid overlapping",
x = "Clusters",
y = "Varin et al rank",
color = "Cluster",
fill = "Cluster")+
theme_classic()+
theme(legend.position = "bottom",
plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
plot.subtitle = element_text(face = "bold.italic", hjust = 0.5),
plot.caption = element_text(face = "italic"))
}else if(true_model == 'Tennis_data'){
for(k in 1:K){
k_members = combined_df %>% filter(est_cl == k)
proportion_wanted = max(round(percentage_to_display / 100 * nrow(k_members)),1)
members_to_sample = proportion_wanted
sampled_row = sample(1:nrow(k_members), size = members_to_sample)
if(!exists('sampled_labels')){
sampled_labels <- k_members[sampled_row, ]
}else{
sampled_labels = rbind(sampled_labels,k_members[sampled_row, ])
}
}
rank_boxplot<- ggplot(combined_df, aes(x = factor(est_cl), y = relative_victories, color = factor(est_cl))) +
geom_boxplot(alpha=.3) +
geom_label_repel(
data = sampled_labels,  # Use the sampled labels for display
aes(label = Id),
size = 3,
hjust = .5,
vjust = 0,
show.legend = F,
alpha=.8
) +
labs(title= "Rank of the players divided into blocks",
subtitle = "Not all names are displayed to avoid overlapping",
x = "Clusters",
y = "Win proportions",
color = "Cluster",
fill = "Cluster")+
theme_classic()+
theme(legend.position = "bottom",
plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
plot.subtitle = element_text(face = "bold.italic", hjust = 0.5),
plot.caption = element_text(face = "italic"))
rm(sampled_labels)
rank_label<- ggplot(combined_df, aes(x = factor(est_cl), y = relative_victories, color = factor(est_cl))) +
geom_point()+
geom_label_repel(aes(label = Id),
size = 3,
hjust = .5,
vjust = 0,
show.legend = F,
alpha=.8
) +
labs(title= "Rank of the players divided into blocks",
subtitle = "Not all names are displayed to avoid overlapping",
x = "Clusters",
y = "Win proportions",
color = "Cluster",
fill = "Cluster")+
theme_classic()+
theme(legend.position = "bottom",
plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
plot.subtitle = element_text(face = "bold.italic", hjust = 0.5),
plot.caption = element_text(face = "italic"))
rm(sampled_labels)
}
plot_name2<- paste0(processed_wd,"//Boxplot",est_model, "_K",K,"_N",nrow(uploaded_results$chain1$Y_ij),".png")
png(plot_name2,width = 800, height = 594)
print(rank_boxplot)
dev.off()
plot_name3<- paste0(processed_wd,"//Rank_Labels",est_model, "_K",K,"_N",nrow(uploaded_results$chain1$Y_ij),".png")
png(plot_name3,width = 1200, height = 1000)
print(rank_label)
dev.off()
}
beepr::beep('coin')
}
loo_model_fit = loo(LL_list[[1]],cores = 3,save_psis = T,r_eff = r_effs)
saveRDS(loo_model_fit, paste0(processed_wd,"/modelcheck",est_model,K,".RDS"))
plot(loo_model_fit)
waic_model_fit = waic(LL_list[[1]])
pareto_k_ids(loo_model_fit)
pareto_k_values(loo_model_fit)
bad_values = loo::pareto_k_ids(loo_model_fit)
bad_values_df = data.frame(item = 0, value=0, bad=T,iteration=0)
good_values = setdiff(1:ncol(LL_list[[1]]), bad_values)
for(t in 1:50){
bad_df = data.frame(item= bad_values, value = LL_list[[1]][t,bad_values], bad=T, iteration=t)
good_df= data.frame(item= good_values, value = LL_list[[1]][t,good_values], bad=F, iteration=t)
bad_values_df = rbind(bad_values_df, bad_df, good_df)
}
bad_values_df%>%
ggplot(aes(x=item, y=value, color=bad))+
geom_point(alpha=0.4)
for(t in 1:25){
bad_df = data.frame(item= bad_values, value = LL_list[[1]][t,bad_values], bad=T, iteration=t)
good_df= data.frame(item= good_values, value = LL_list[[1]][t,good_values], bad=F, iteration=t)
bad_values_df = rbind(bad_values_df, bad_df, good_df)
}
bad_values_df%>%
ggplot(aes(x=item, y=value, color=bad))+
geom_point(alpha=0.4)
ppc_loo_pit_qq(
y = upper.tri.Y_ij,
yrep = Y_pred,
lw = weights(loo_model_fit$psis_object)
)
ppc_loo_pit_overlay( y = upper.tri.Y_ij,
yrep = Y_pred,
lw = weights(loo_model_fit$psis_object))
readRDS("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/results/MCMC_output/Fixed_K/Application/processed/Tennis_new/modelcheckSimple6.RDS")
readRDS("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/results/MCMC_output/Fixed_K/Application/processed/Tennis_new/modelcheckSST6.RDS")
model_check_SST = readRDS("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/results/MCMC_output/Fixed_K/Application/processed/Tennis_new/modelcheckSST6.RDS")
library(loo)
library(gridExtra)
gridExtra::arrangeGrob(model_check_simple.model_check_SST)
model_check_simple = readRDS("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/results/MCMC_output/Fixed_K/Application/processed/Tennis_new/modelcheckSimple6.RDS")
model_check_SST = readRDS("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/results/MCMC_output/Fixed_K/Application/processed/Tennis_new/modelcheckSST6.RDS")
library(loo)
library(gridExtra)
gridExtra::arrangeGrob(model_check_simple.model_check_SST)
gridExtra::arrangeGrob(model_check_simple,model_check_SST)
model_check_simple = readRDS("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/results/MCMC_output/Fixed_K/Application/processed/Tennis_new/modelcheckSimple6.RDS")
model_check_SST = readRDS("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/results/MCMC_output/Fixed_K/Application/processed/Tennis_new/modelcheckSST6.RDS")
library(loo)
library(gridExtra)
grid_grob = gridExtra::arrangeGrob(model_check_simple,model_check_SST)
print(grid_grob)
loo::compare(model_check_simple,model_check_SST)
loo_compare(model_check_simple,model_check_SST)
loo_compare(Simple = model_check_simple,SST = model_check_SST)
loo_compare(model_check_simple, model_check_SST)
model_check_SST
model_check_simple
model_check_SST
model_check_simple
model_check_SST
model_check_simple = readRDS("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/results/MCMC_output/Fixed_K/Application/processed/Tennis_new/modelcheckSimple6.RDS")
model_check_simple
model_check_SST
model_check_simple
print(grid_grob)
loo_compare(model_check_simple, model_check_SST)
loo_model_fit
source("~/Desktop/Nial/POMM_pairwise/POMMs/model_auxiliary_functions/reading_resultS.R", echo=TRUE)
source("~/Desktop/Nial/POMM_pairwise/POMMs/model_auxiliary_functions/reading_resultS.R", echo=TRUE)
source("~/Desktop/Nial/POMM_pairwise/POMMs/model_auxiliary_functions/reading_resultS.R", echo=TRUE)
# dbinom(upper.tri.Y_ij[which(bad_values == Inf)] , upper.tri.N_ij[which(bad_values == Inf)], P_ij[which(bad_values == Inf)], log = T)
# dbinom(upper.tri.Y_ij[is.na(bad_values)] , upper.tri.N_ij[is.na(bad_values)], P_ij[is.na(bad_values)], log = T)
#
# dbinom(upper.tri.Y_ij[961] , upper.tri.N_ij[961], P_ij[961], log = T)
#
# ppc_loo_pit_qq(
#   y = upper.tri.Y_ij,
#   yrep = Y_pred,
#   lw = weights(loo_model_fit$psis_object)
# )
ppc_loo_pit_overlay( y = upper.tri.Y_ij,
#                      yrep = Y_pred,
#                      lw = weights(loo_model_fit$psis_object))
#
# ppc_bars(y = upper.tri.Y_ij,
#                  yrep = Y_pred_short)
if(is.simulation==F){
z_s_table = data.frame(lone_out = loo_model_fit$estimates[1],lone_out_se = loo_model_fit$estimates[4],
waic = waic_model_fit$estimates[1], waic_se = waic_model_fit$estimates[4],
percent_bad_values=    round(pareto_k_table(loo_model_fit)[8],4)*100,
K0_hat =     K0_hat,
perc_label_switch = my_z_est$label_switch_count/N*100,
K0_hat_switched = K0_hat_switched)
}else if(is.simulation==T){
z_s_table = data.frame(lone_out = loo_model_fit$estimates[1],lone_out_se = loo_model_fit$estimates[4],
waic = waic_model_fit$estimates[1], waic_se = waic_model_fit$estimates[4],
percent_bad_values=    round(pareto_k_table(loo_model_fit)[8],4)*100,
vi_dist = vi.dist(uploaded_results$chain1$ground_truth$z, point_est_z),
K0_hat_nolabel_sw=    K0_hat,
perc_label_switch = my_z_est$label_switch_count/N*100,
K0_hat_switched = K0_hat_switched)
}
z_s_table = z_s_table %>% mutate(model=est_model)%>% mutate(n_clust = K)
# dbinom(upper.tri.Y_ij[which(bad_values == Inf)] , upper.tri.N_ij[which(bad_values == Inf)], P_ij[which(bad_values == Inf)], log = T)
# dbinom(upper.tri.Y_ij[is.na(bad_values)] , upper.tri.N_ij[is.na(bad_values)], P_ij[is.na(bad_values)], log = T)
#
# dbinom(upper.tri.Y_ij[961] , upper.tri.N_ij[961], P_ij[961], log = T)
#
# ppc_loo_pit_qq(
#   y = upper.tri.Y_ij,
#   yrep = Y_pred,
#   lw = weights(loo_model_fit$psis_object)
# )
ppc_loo_pit_overlay( y = upper.tri.Y_ij,
yrep = Y_pred,
lw = weights(loo_model_fit$psis_object))
# dbinom(upper.tri.Y_ij[which(bad_values == Inf)] , upper.tri.N_ij[which(bad_values == Inf)], P_ij[which(bad_values == Inf)], log = T)
# dbinom(upper.tri.Y_ij[is.na(bad_values)] , upper.tri.N_ij[is.na(bad_values)], P_ij[is.na(bad_values)], log = T)
#
# dbinom(upper.tri.Y_ij[961] , upper.tri.N_ij[961], P_ij[961], log = T)
#
# ppc_loo_pit_qq(
#   y = upper.tri.Y_ij,
#   yrep = Y_pred,
#   lw = weights(loo_model_fit$psis_object)
# )
ppc_loo_pit_overlay( y = upper.tri.Y_ij,
yrep = Y_pred,
lw = weights(loo_model_fit$psis_object))+
labs(x = 'uniform',title = 'hi')
# dbinom(upper.tri.Y_ij[which(bad_values == Inf)] , upper.tri.N_ij[which(bad_values == Inf)], P_ij[which(bad_values == Inf)], log = T)
# dbinom(upper.tri.Y_ij[is.na(bad_values)] , upper.tri.N_ij[is.na(bad_values)], P_ij[is.na(bad_values)], log = T)
#
# dbinom(upper.tri.Y_ij[961] , upper.tri.N_ij[961], P_ij[961], log = T)
#
# ppc_loo_pit_qq(
#   y = upper.tri.Y_ij,
#   yrep = Y_pred,
#   lw = weights(loo_model_fit$psis_object)
# )
ppc_loo_pit_overlay( y = upper.tri.Y_ij,
yrep = Y_pred,
lw = weights(loo_model_fit$psis_object))+
labs(x = 'uniform',title = paste0('posterior predictive PIT'),
subtitle = paste0('Model',est_model,"K",K),
caption = paste0("data source:",true_model))
# dbinom(upper.tri.Y_ij[which(bad_values == Inf)] , upper.tri.N_ij[which(bad_values == Inf)], P_ij[which(bad_values == Inf)], log = T)
# dbinom(upper.tri.Y_ij[is.na(bad_values)] , upper.tri.N_ij[is.na(bad_values)], P_ij[is.na(bad_values)], log = T)
#
# dbinom(upper.tri.Y_ij[961] , upper.tri.N_ij[961], P_ij[961], log = T)
#
# ppc_loo_pit_qq(
#   y = upper.tri.Y_ij,
#   yrep = Y_pred,
#   lw = weights(loo_model_fit$psis_object)
# )
ppc_loo_pit_overlay( y = upper.tri.Y_ij,
yrep = Y_pred,
lw = weights(loo_model_fit$psis_object))+
labs(x = 'uniform',title = paste0('posterior predictive PIT'),
subtitle = paste0('Model =',est_model,", K=",K),
caption = paste0("data source:",true_model))
# dbinom(upper.tri.Y_ij[which(bad_values == Inf)] , upper.tri.N_ij[which(bad_values == Inf)], P_ij[which(bad_values == Inf)], log = T)
# dbinom(upper.tri.Y_ij[is.na(bad_values)] , upper.tri.N_ij[is.na(bad_values)], P_ij[is.na(bad_values)], log = T)
#
# dbinom(upper.tri.Y_ij[961] , upper.tri.N_ij[961], P_ij[961], log = T)
#
# ppc_loo_pit_qq(
#   y = upper.tri.Y_ij,
#   yrep = Y_pred,
#   lw = weights(loo_model_fit$psis_object)
# )
ppc_loo_pit_overlay( y = upper.tri.Y_ij,
yrep = Y_pred,
lw = weights(loo_model_fit$psis_object))+
labs(x = 'uniform',title = paste0('Posterior Predictive LOO-PIT'),
subtitle = paste0('Model =',est_model,", K=",K),
caption = paste0("data source:",true_model))
ggsave(diagnostic2,path = paste0(processed_wd,'diagnostic2',est_model,K,".png"))
# dbinom(upper.tri.Y_ij[which(bad_values == Inf)] , upper.tri.N_ij[which(bad_values == Inf)], P_ij[which(bad_values == Inf)], log = T)
# dbinom(upper.tri.Y_ij[is.na(bad_values)] , upper.tri.N_ij[is.na(bad_values)], P_ij[is.na(bad_values)], log = T)
#
# dbinom(upper.tri.Y_ij[961] , upper.tri.N_ij[961], P_ij[961], log = T)
#
# ppc_loo_pit_qq(
#   y = upper.tri.Y_ij,
#   yrep = Y_pred,
#   lw = weights(loo_model_fit$psis_object)
# )
diagnostic2 = ppc_loo_pit_overlay( y = upper.tri.Y_ij,
yrep = Y_pred,
lw = weights(loo_model_fit$psis_object))+
labs(x = 'uniform',title = paste0('Posterior Predictive LOO-PIT'),
subtitle = paste0('Model =',est_model,", K=",K),
caption = paste0("data source:",true_model))
ggsave(diagnostic2,path = paste0(processed_wd,'diagnostic2',est_model,K,".png"))
ggsave(plot=diagnostic2,filename = paste0(processed_wd,'diagnostic2',est_model,K,".png"))
# dbinom(upper.tri.Y_ij[which(bad_values == Inf)] , upper.tri.N_ij[which(bad_values == Inf)], P_ij[which(bad_values == Inf)], log = T)
# dbinom(upper.tri.Y_ij[is.na(bad_values)] , upper.tri.N_ij[is.na(bad_values)], P_ij[is.na(bad_values)], log = T)
#
# dbinom(upper.tri.Y_ij[961] , upper.tri.N_ij[961], P_ij[961], log = T)
#
ppc_loo_pit_qq(
y = upper.tri.Y_ij,
yrep = Y_pred,
lw = weights(loo_model_fit$psis_object)
)+
labs(x = 'uniform',title = paste0('Posterior Predictive LOO-PIT'),
subtitle = paste0('Model =',est_model,", K=",K),
caption = paste0("data source:",true_model))
#
diagnostic3 = ppc_bars(y = upper.tri.Y_ij,
yrep = Y_pred_short)
diagnostic3
source("~/Desktop/Nial/POMM_pairwise/POMMs/model_auxiliary_functions/reading_resultS.R", echo=TRUE)
