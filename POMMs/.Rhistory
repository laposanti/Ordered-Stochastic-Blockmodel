for(d in 0:(K-1)){
theta_current[col(theta_current)-row(theta_current)==d]<- runif(K-d, min  = -5 ,
max = +10)
}
}
theta_current[lower.tri(theta_current)] = - t(theta_current)[lower.tri(theta_current)]
}else{
theta_current=  as.matrix(ground_truth$theta)
}
theta_current
labels_available<- 1:K
#checking that we have exactly K labels
label_counts <- table(factor(z_current, levels = labels_available))
n_k = as.numeric(label_counts)
while(any(n_k==0)){
k_missing = which(n_k == 0)
for(i in 1:length(k_missing)){
z_current[sample(n, size = n*1/K, replace = F)] <- k_missing[i]
label_counts <- table(factor(z_current, levels = labels_available))
n_k = as.numeric(label_counts)
}
}
z_P = vec2mat(z_current)
labels_available<- 1:K
#checking that we have exactly K labels
label_counts <- table(factor(z_current, levels = labels_available))
n_k = as.numeric(label_counts)
while(any(n_k==0)){
k_missing = which(n_k == 0)
for(i in 1:length(k_missing)){
z_current[sample(n, size = n*1/K, replace = F)] <- k_missing[i]
label_counts <- table(factor(z_current, levels = labels_available))
n_k = as.numeric(label_counts)
}
}
z_P = vec2mat(z_current)
A_current =  ll_naive(z = z_current, theta = theta_current, Y_ij = Y_ij, N_ij= N_ij)*t
check = lprop_posterior(z = z_current,
Y_ij = Y_ij,
N_ij = N_ij,
theta =theta_current,
alpha_vec = alpha_vec,
n_k = n_k,
sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,
K = K,
model = model,  t=t)
#initialising the chain
A_container <- matrix(0, nrow = 1, ncol = N_iter-burnin)
A_container[1] <- A_current
#initialising the chain
z_container <- matrix(0, nrow = n, ncol = N_iter-burnin)
z_container[,1] <- z_current
if(model == 'WST'){
#initialising the chain
sigma_squared_container =  matrix(0, nrow = 1, ncol = N_iter-burnin)
sigma_squared_container[1] <- sigma_squared_current
#initialising the adaptive variance
tau_sigma_squared <- 0.2
tau_sigma_squared_container = matrix(0,1, N_iter)
tau_sigma_squared_container[1] <- tau_sigma_squared
}else{
tau_sigma_squared <- NA
sigma_squared_container <- NA
tau_sigma_squared_container <- NA
}
if(model == 'WST'||model == 'SST'){
#initialising the chain
mu_vec_container = matrix(0, nrow = K+1, ncol = N_iter-burnin)
mu_vec_container[,1] <- mu_vec_current
#initialising the adaptive variance
tau_mu_vec <- 0.1
tau_mu_vec_container = matrix(0,1, N_iter)
tau_mu_vec_container[1] <- tau_mu_vec
}else{
mu_vec_container <- NA
tau_mu_vec <- NA
tau_mu_vec_container <- NA
}
#initialing theta and its adaptive variance container
theta_container = array(0, dim = c(K,K,N_iter-burnin))
theta_container[,,1] <- theta_current
tau_theta_container = array(0,dim=c(K,K,N_iter))
tau_theta =matrix(0.25,K,K)
tau_theta_container[,,1] = tau_theta
#containers for the counts of accepted proposals
acc.count_z = rep(1,n)
acc.count_sigma_squared=1
acc.count_mu_vec = rep(1, K+1)
acc.count_theta<- matrix(1,K,K)
#READY TO BOMB!
iteration_time= vector()
for(j in 2:N_iter){
set.seed(chains_seed[[chain]])
start_time <- Sys.time()
if (estimation_control$z == 1) {
#z UPDATE-------------------------------------------------------------
z_update = z_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,theta =theta_current,
lamdabar = lamdabar,ybar=ybar,
mbar=mbar,alpha_vec = alpha_vec,
n_k = n_k,K = K,
acc.count_z = acc.count_z,
labels_available = labels_available,
model, t=t)
llik = z_update$A_prime
z_current = z_update$z
acc.count_z = z_update$acc.moves
label_counts <- table(factor(z_current, levels = labels_available))
n_k = as.numeric(label_counts)
}
if (estimation_control$theta == 1) {
#theta UPDATE-------------------------------------------------------------
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
llik = theta_update$llik
theta_current = theta_update$theta
acc.count_theta =theta_update$acc.moves
# if(j %% 50 == 0){
#
#   for(my_p in 1:K){
#     for(my_q in my_p:K){
#
#       tau_theta[my_p,my_q] = tuning_proposal(iteration = j,
#                                              acceptance_count = acc.count_theta[my_p,my_q],
#                                              sigma = tau_theta[my_p,my_q],
#                                              acceptanceTarget = optimal_acceptance_rate_theta,
#                                              min_sigma = 0.00002)
#
#     }
#   }
# }
}
if (estimation_control$sigma_squared == 1) {
#sigma_squared UPDATE----------------------------------------------------------------
sigma_squared_update <- sigma_squared_update_f(z = z_current, N_ij = N_ij, llik = llik,
Y_ij = Y_ij, theta =theta_current,
alpha_vec = alpha_vec, n_k = n_k,
sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,
K = K, tau_sigma_squared = tau_sigma_squared,
acc.count_sigma_squared = acc.count_sigma_squared,model,t=t)
#updating quantities
acc.count_sigma_squared = sigma_squared_update$acc.moves
sigma_squared_current = sigma_squared_update$sigma_squared
# if(j %% 50 == 0 ){
#   tau_sigma_squared <- tuning_proposal(iteration=j,
#                                        acceptance_count = acc.count_sigma_squared,
#                                        sigma = tau_sigma_squared,
#                                        acceptanceTarget = optimal_acceptance_rate_theta,
#                                        min_sigma = 0.02)
# }
}
if (estimation_control$mu== 1) {
#mu UPDATE----------------------------------------------------------------
mu_update=  mu_update_f(z = z_current, N_ij = N_ij, llik=llik,
Y_ij = Y_ij,  theta =theta_current,
alpha_vec =  alpha_vec, n_k = n_k,
sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K, tau_mu_vec = tau_mu_vec,
acc.count_mu_vec,model,t=t)
#updating quantities
mu_vec_current = mu_update$mu_vec
acc.count_mu_vec = mu_update$acc.moves
#
# if(j %% 50 == 0){
#   tau_mu_vec <- tuning_proposal(iteration=j,acceptance_count = acc.count_mu_vec,
#                                 sigma = tau_mu_vec,
#                                 acceptanceTarget = optimal_acceptance_rate_mu,
#                                 min_sigma = 0.002)
# }
#
}
#storing scales
# tau_sigma_squared_container[j]<- tau_sigma_squared
# tau_mu_vec_container[j]<- tau_mu_vec
# tau_theta_container[,,j]<- tau_theta
#
#storing results for inference
if(j > burnin){
j_burned = j - burnin
z_container[,j_burned] <- z_current
theta_container[,,j_burned] <- theta_current
if(model == 'WST'){
sigma_squared_container[1,j_burned] = sigma_squared_current
}
if(model == 'WST'|| model=='SST'){
mu_vec_container[,j_burned] <- mu_vec_current
}
}
# #storing scales
# tau_sigma_squared_container[j]<- tau_sigma_squared
# tau_mu_vec_container[j]<- tau_mu_vec
# tau_theta_container[,,j]<- tau_theta
#
#
end_time <- Sys.time()
iteration_time<-append(iteration_time,as.numeric(difftime(end_time, start_time, units = "secs")))
}
theta_current
theta_container[,,j_burned]
theta_container
acc.count_theta
j
where_to_save[[i]]
for(i in 1:length(K_est)){
where_to_save[[i]] =  file.path(saving_directory, paste0("model_selection/MCMC_output/",data_description,"/",model,"/K", K_est[[i]],"/"))
dir.create(where_to_save[[i]], showWarnings = T, recursive = T)
}
where_to_save
source("~/Desktop/Nial/POMM_pairwise/POMMs/Simulation_launcher.R", echo=TRUE)
source("~/Desktop/Nial/POMM_pairwise/POMMs/Simulation_launcher.R", echo=TRUE)
mean(chains_SST$est_containers$theta[1,2,]) - chains_SST$ground_truth$theta[1,3]
chains_SST <- adaptive_MCMC_orderstats_powerposterior(Y_ij = Y_ij, N_ij = N_ij,
saving_directory = saving_directory,
estimation_control = estimation_control,
burnin = burnin,
ground_truth = ground_truth,
n = n, N_iter = N_iter,
K_est = K_est,data_description = data_description,
seed = seed,
model = est_model,
custom_init = custom_init,
power_posterior_apprach = F)
estimation_control <- list(z = 0, sigma_squared = 0, mu_vec = 0, K = 0, theta = 1)
chains_SST <- adaptive_MCMC_orderstats_powerposterior(Y_ij = Y_ij, N_ij = N_ij,
saving_directory = saving_directory,
estimation_control = estimation_control,
burnin = burnin,
ground_truth = ground_truth,
n = n, N_iter = N_iter,
K_est = K_est,data_description = data_description,
seed = seed,
model = est_model,
custom_init = custom_init,
power_posterior_apprach = F)
seed=23
estimation_control <- list(z = 0, sigma_squared = 0, mu_vec = 0, K = 0, theta = 1)
chains_SST <- adaptive_MCMC_orderstats_powerposterior(Y_ij = Y_ij, N_ij = N_ij,
saving_directory = saving_directory,
estimation_control = estimation_control,
burnin = burnin,
ground_truth = ground_truth,
n = n, N_iter = N_iter,
K_est = K_est,data_description = data_description,
seed = seed,
model = est_model,
custom_init = custom_init,
power_posterior_apprach = F)
mean(chains_SST$est_containers$theta[1,2,]) - chains_SST$ground_truth$theta[1,3]
mean(chains_SST$est_containers$theta[1,2,])
mean(chains_SST$est_containers$theta[1,2,])
chains_SST$ground_truth$theta[1,3]
mean(chains_SST$est_containers$theta[1,3,]) - chains_SST$ground_truth$theta[1,3]
mean(chains_SST$est_containers$theta[1,3,])
chains_SST$ground_truth$theta[1,3]
chains_SST$acceptance_rates$acc.count_theta
#setting up the chain hyperparameter
N_iter <- 3000 #number of iterations
burnin <- 0  #number of discarded iterations
K_est = list(3) #number of clusters to fit
#where to save the data
saving_directory = "./Results/"
#Boolean: power_posterior_approach = T estimates the marginal likelihood via power posteriors
power_posterior_apprach = T
custom_init <- NA
print(paste0("Estimation of the SST model, K=", K_est))
print(paste0("Begin cycle at:", date(), "\n"))
seed=23
estimation_control <- list(z = 0, sigma_squared = 0, mu_vec = 0, K = 0, theta = 1)
chains_SST <- adaptive_MCMC_orderstats_powerposterior(Y_ij = Y_ij, N_ij = N_ij,
saving_directory = saving_directory,
estimation_control = estimation_control,
burnin = burnin,
ground_truth = ground_truth,
n = n, N_iter = N_iter,
K_est = K_est,data_description = data_description,
seed = seed,
model = est_model,
custom_init = custom_init,
power_posterior_apprach = F)
K_est = list(3) #number of clusters to fit
est_model = 'SST'
#setting up the chain hyperparameter
N_iter <- 3000 #number of iterations
burnin <- 0  #number of discarded iterations
K_est = list(3) #number of clusters to fit
#where to save the data
saving_directory = "./Results/"
#Boolean: power_posterior_approach = T estimates the marginal likelihood via power posteriors
power_posterior_apprach = T
custom_init <- NA
print(paste0("Estimation of the SST model, K=", K_est))
print(paste0("Begin cycle at:", date(), "\n"))
seed=23
estimation_control <- list(z = 0, sigma_squared = 0, mu_vec = 0, K = 0, theta = 1)
chains_SST <- adaptive_MCMC_orderstats_powerposterior(Y_ij = Y_ij, N_ij = N_ij,
saving_directory = saving_directory,
estimation_control = estimation_control,
burnin = burnin,
ground_truth = ground_truth,
n = n, N_iter = N_iter,
K_est = K_est,data_description = data_description,
seed = seed,
model = est_model,
custom_init = custom_init,
power_posterior_apprach = F)
mean(chains_SST$est_containers$theta[1,3,]) - chains_SST$ground_truth$theta[1,3]
chains_SST$acceptance_rates$acc.count_theta
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
abort
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
theta_update
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
theta_update
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
llik = theta_update$llik
theta_current = theta_update$theta
acc.count_theta =theta_update$acc.moves
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
theta_update
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
llik = theta_update$llik
theta_current = theta_update$theta
acc.count_theta =theta_update$acc.moves
theta_update
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
llik = theta_update$llik
theta_current = theta_update$theta
acc.count_theta =theta_update$acc.moves
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
llik = theta_update$llik
theta_current = theta_update$theta
acc.count_theta =theta_update$acc.moves
theta_update
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
llik = theta_update$llik
theta_current = theta_update$theta
acc.count_theta =theta_update$acc.moves
theta_update
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
llik = theta_update$llik
theta_current = theta_update$theta
acc.count_theta =theta_update$acc.moves
theta_update
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
llik = theta_update$llik
theta_current = theta_update$theta
acc.count_theta =theta_update$acc.moves
theta_update
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
llik = theta_update$llik
theta_current = theta_update$theta
acc.count_theta =theta_update$acc.moves
theta_update
sum(acc.count_theta)
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
llik = theta_update$llik
theta_current = theta_update$theta
acc.count_theta =theta_update$acc.moves
sum(acc.count_theta)
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
llik = theta_update$llik
theta_current = theta_update$theta
acc.count_theta =theta_update$acc.moves
sum(acc.count_theta)
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
llik = theta_update$llik
theta_current = theta_update$theta
acc.count_theta =theta_update$acc.moves
sum(acc.count_theta)
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
llik = theta_update$llik
theta_current = theta_update$theta
acc.count_theta =theta_update$acc.moves
sum(acc.count_theta)
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
llik = theta_update$llik
theta_current = theta_update$theta
acc.count_theta =theta_update$acc.moves
sum(acc.count_theta)
theta_update = theta_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
llik = theta_update$llik
theta_current = theta_update$theta
acc.count_theta =theta_update$acc.moves
sum(acc.count_theta)
#
#       tau_theta[my_p,my_q] = tuning_proposal(iteration = j,
#                                              acceptance_count = acc.count_theta[my_p,my_q],
#                                              sigma = tau_theta[my_p,my_q],
#                                              acceptanceTarget = optimal_acceptance_rate_theta,
#                                              min_sigma = 0.00002)
#
#     }
#   }
# }
}
source("~/Desktop/Nial/POMM_pairwise/POMMs/Simulation_launcher.R", echo=TRUE)
Q
mean(chains_SST$est_containers$theta[1,3,]) - chains_SST$ground_truth$theta[1,3]
mean(chains_SST$est_containers$theta[1,3,]) - chains_SST$ground_truth$theta[1,3]
mean(chains_SST$chain1$est_containers$theta[1,3,]) - chains_SST$ground_truth$theta[1,3]
mean(chains_SST$chain1$est_containers$theta[1,3,])
chains_SST$ground_truth$theta[1,3]
mean(chains_SST$chain1$est_containers$theta[1,3,]) - chains_SST$chain1$ground_truth$theta[1,3]
Q
