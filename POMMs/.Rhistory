}
if(model == 'SST'){
to_be_returned = list(P = P_prime, mu= mu_vec_sort)
}else{
to_be_returned = list(P = P_prime)
}
return(to_be_returned)
}
true_model = 'SST'
saving_directory="/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/Data/Sim1_data///"
#from 1, 'very difficult' to 5, 'very easy'
recovery_capability_levels = 1:5
for(k in 7){
for(recovery_capability in 1:length(recovery_capability_levels)){
recovery_capability=5
n = 80
K=k
seed =2021
set.seed(seed)
if(true_model =='SST'){
prior_SST = generate_theta_from_theta_prior(K,
model = 'SST')
P <- prior_SST$P
mu_vec =  prior_SST$mu
theta = log(P/(1-P))
}else if(true_model == 'WST'){
prior_WST = generate_theta_from_theta_prior(K,
model = 'WST')
P <- prior_WST$P
mu_vec =  prior_WST$mu
theta = log(P/(1-P))
}else if( true_model == 'Simple'){
prior_Simple =  generate_theta_from_theta_prior(K,
model = 'Simple')
P = prior_Simple$P
P[lower.tri(P)] = 1- t(P)[lower.tri(P)]
print(P)
theta = log(P/(1-P))
}
print(P)
z <- sample(1:K, n,replace=T)
z_P<- vec2mat_0_P(clust_lab = z,P = P)
P_nbyn<- calculate_victory_probabilities(z_mat = z_P,P = P)
#Here we compute a KxK matrix cotaining the average number of comparisons between pairs of blocks
num_comparisons = recovery_capability:(recovery_capability+2)
N_blocks = matrix(sample(x = num_comparisons,
size = K**2,replace = T),
nrow = K,ncol = K)
N_blocks = make_symmetric(N_blocks)
N_ij = matrix(NA, n, n)
for(i in 1:n){
for(j in 1:n){
N_ij[i,j] = rpois(1,N_blocks[z[i], z[j]])
}
}
N_ij[lower.tri(N_ij)] = t(N_ij)[lower.tri(N_ij)]
diag(N_ij) = 0
#simulating Y_ij
Y_ij <- matrix(0, n,n)
for(i in 1:n){
for(j in 1:n){
Y_ij[i,j]<-rbinom(1,N_ij[i,j], P_nbyn[i,j])
}
}
Y_ij[lower.tri(Y_ij)] = N_ij[lower.tri(N_ij)] - t(Y_ij)[lower.tri(Y_ij)]
diag(Y_ij)<- 0
indices <- expand.grid(row = 1:n, col = 1:n)
z_df <- data.frame(items = 1:n,
z = z)
# Convert the matrix to a data frame
z_df_complete <- data.frame(
row = indices$row,
col = indices$col,
similarity_value = NA,
Y = NA
)
for (i in seq_len(nrow(z_df_complete))) {
z_df_complete$Y[i] <- Y_ij[z_df_complete$col[i], z_df_complete$row[i]]
}
for (i in seq_len(nrow(z_df_complete))) {
z_df_complete$N[i] <- N_ij[z_df_complete$col[i], z_df_complete$row[i]]
}
z_df_complete$y_prop = z_df_complete$Y/z_df_complete$N
plot_df = z_df_complete%>%
inner_join(z_df, by = c("row" = "items")) %>%
rename(row_z = z) %>%
inner_join(z_df, by = c("col" = "items")) %>%
rename(col_z = z) %>%
mutate(row = factor(row, levels = unique(row[order(row_z, row)])),
col = factor(col, levels = unique(col[order(col_z, col, decreasing = TRUE)])))
adjacency_m <- ggplot(plot_df, aes(x = row, y = col)) +
geom_tile(aes(fill = y_prop), color = 'gray30') +
scale_fill_gradient(low = 'grey', high = 'red') +
geom_ysidetile(aes(color = factor(col_z)), show.legend = FALSE, width = 0.5) +
theme_minimal() +
theme(axis.text.x = element_blank(),
axis.text.y = element_blank(),
axis.title.x = element_blank(),
axis.title.y = element_blank(),
legend.position = "bottom", # Position legend below the graph
legend.direction = "horizontal", # Extend legend horizontally,
legend.key.width = unit(1.1, 'cm'),
) +
guides(fill = guide_colorbar(title.position = "top", title.hjust = 0.5)) # Center the title horizontally
adjacency_m
print(adjacency_m)
if(true_model == 'SST'){
ground_truth = list(z = z,
mu_vec_star = mu_vec,
K=K,theta=theta,
model = true_model)
}else if(true_model == 'WST'){
ground_truth = list(z = z,
mu_vec_star = mu_vec,
K=K,
theta=theta,
model = true_model)
}else if(true_model == 'Simple'){
ground_truth = list(z = z,
mu_vec_star = NA,
K=K,
theta=theta,
model = true_model)
}
to_be_saved = list(Y_ij=Y_ij, N_ij =N_ij, ground_truth = ground_truth,
data_plot = adjacency_m,
recovery_capability = recovery_capability,
seed=seed)
saveRDS(to_be_saved, paste0(saving_directory, true_model, K,"_level_recovery",recovery_capability,".RDS"))
}
}
library(doFuture)
library(progressr)
library(beepr)
library(foreach)
library(doParallel)
library(tidyverse)
library(EnvStats)
library(truncnorm)
library(dplyr)
library(ggplot2)
library(dplyr)
library(RColorBrewer)
library(ggside)
library(truncnorm)
library(doRNG)
source("/Users/lapo_santi/Desktop/Nial/oldmaterial/project/simplified model/Functions_priorSST.R")
source("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/Metropolis_within_Gibbs_code.R")
source("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/model_auxiliary_functions/MCMC_functions.R")
generate_theta_from_theta_prior = function(K, model){
print(paste0('You are simulating theta according to the ', model, ' model prior'))
if(model == 'SST'){
mu_vec_01_sort = seq(from = 0.5,to = 0.9, length.out = K)
mu_vec_sort = log(mu_vec_01_sort/(1-mu_vec_01_sort))
ut <- upper.tri(matrix(0,K,K),diag = T) # get the logical matrix for upper triangular elements
Pcombn = which(ut, arr.ind = TRUE) # get the indices of the upper triangular elements
uo<- data.frame(Pcombn[sample(nrow(Pcombn)), ])# permuting the order of the rows
n_P_entries<- nrow(uo)
theta_prime<-matrix(0,K,K)
for(i_th in 1:n_P_entries){
i_star<- uo$row[i_th]
j_star<- uo$col[i_th]
theta_prime[i_star,j_star]<- mu_vec_sort[j_star - i_star + 1]
}
theta_prime[lower.tri(theta_prime)] = - t(theta_prime)[lower.tri(theta_prime)]
P_prime = inverse_logit_f(theta_prime)
}else if(model == 'WST'){
P_prime = matrix(NA, K, K)
P_prime[col(P_prime)-row(P_prime)==0] <-runif(K, 0,1)
for(diag_i in 1:(K-1)){
P_prime[col(P_prime)-row(P_prime)==diag_i] <- runif( K-diag_i,min = 0.5,max = 1)
}
diag(P_prime) = 0.5
P_prime[lower.tri(P_prime)] = 1-t(P_prime)[lower.tri(P_prime)]
}else if(model == 'Simple'){
#upper triangular entries should not be greater than 0.5 (WST axiom)
#nor increasing in the columns and decreasing in the rows (SST axiom)
P_prime = matrix(NA, K, K)
P_prime[col(P_prime)-row(P_prime)==0] <-runif(K, 0,1)
for(diag_i in 1:(K-1)){
P_prime[col(P_prime)-row(P_prime)==diag_i] <- runif( K-diag_i,min = 0,max = 1)
}
diag(P_prime) = 0.5
P_prime[lower.tri(P_prime)] = 1-t(P_prime)[lower.tri(P_prime)]
#check for P
violating_WST_percent = 1- sum(P_prime >=0.5 & upper.tri(P_prime,diag = T))/sum(upper.tri(P_prime,diag = T))
while(violating_WST_percent < .4){
P_prime = matrix(NA, K, K)
P_prime[col(P_prime)-row(P_prime)==0] <-runif(K, 0,1)
for(diag_i in 1:(K-1)){
P_prime[col(P_prime)-row(P_prime)==diag_i] <- runif( K-diag_i,min = 0,max = 1)
}
violating_WST_percent = 1- sum(P_prime >=0.5 & upper.tri(P_prime,diag = T))/sum(upper.tri(P_prime,diag = T))
}
}
if(model == 'SST'){
to_be_returned = list(P = P_prime, mu= mu_vec_sort)
}else{
to_be_returned = list(P = P_prime)
}
return(to_be_returned)
}
true_model = 'SST'
saving_directory="/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/Data/Sim1_data///"
#from 1, 'very difficult' to 5, 'very easy'
recovery_capability_levels = 1:5
for(k in 7){
for(recovery_capability in 1:length(recovery_capability_levels)){
recovery_capability=5
n = 80
K=k
seed =2021
set.seed(seed)
if(true_model =='SST'){
prior_SST = generate_theta_from_theta_prior(K,
model = 'SST')
P <- prior_SST$P
mu_vec =  prior_SST$mu
theta = log(P/(1-P))
}else if(true_model == 'WST'){
prior_WST = generate_theta_from_theta_prior(K,
model = 'WST')
P <- prior_WST$P
mu_vec =  prior_WST$mu
theta = log(P/(1-P))
}else if( true_model == 'Simple'){
prior_Simple =  generate_theta_from_theta_prior(K,
model = 'Simple')
P = prior_Simple$P
P[lower.tri(P)] = 1- t(P)[lower.tri(P)]
print(P)
theta = log(P/(1-P))
}
print(P)
z <- sample(1:K, n,replace=T)
z_P<- vec2mat_0_P(clust_lab = z,P = P)
P_nbyn<- calculate_victory_probabilities(z_mat = z_P,P = P)
#Here we compute a KxK matrix cotaining the average number of comparisons between pairs of blocks
num_comparisons = recovery_capability:(recovery_capability+2)
N_blocks = matrix(sample(x = num_comparisons,
size = K**2,replace = T),
nrow = K,ncol = K)
N_blocks = make_symmetric(N_blocks)
N_ij = matrix(NA, n, n)
for(i in 1:n){
for(j in 1:n){
N_ij[i,j] = rpois(1,N_blocks[z[i], z[j]])
}
}
N_ij[lower.tri(N_ij)] = t(N_ij)[lower.tri(N_ij)]
diag(N_ij) = 0
#simulating Y_ij
Y_ij <- matrix(0, n,n)
for(i in 1:n){
for(j in 1:n){
Y_ij[i,j]<-rbinom(1,N_ij[i,j], P_nbyn[i,j])
}
}
Y_ij[lower.tri(Y_ij)] = N_ij[lower.tri(N_ij)] - t(Y_ij)[lower.tri(Y_ij)]
diag(Y_ij)<- 0
indices <- expand.grid(row = 1:n, col = 1:n)
z_df <- data.frame(items = 1:n,
z = z)
# Convert the matrix to a data frame
z_df_complete <- data.frame(
row = indices$row,
col = indices$col,
similarity_value = NA,
Y = NA
)
for (i in seq_len(nrow(z_df_complete))) {
z_df_complete$Y[i] <- Y_ij[z_df_complete$col[i], z_df_complete$row[i]]
}
for (i in seq_len(nrow(z_df_complete))) {
z_df_complete$N[i] <- N_ij[z_df_complete$col[i], z_df_complete$row[i]]
}
z_df_complete$y_prop = z_df_complete$Y/z_df_complete$N
plot_df = z_df_complete%>%
inner_join(z_df, by = c("row" = "items")) %>%
rename(row_z = z) %>%
inner_join(z_df, by = c("col" = "items")) %>%
rename(col_z = z) %>%
mutate(row = factor(row, levels = unique(row[order(row_z, row)])),
col = factor(col, levels = unique(col[order(col_z, col, decreasing = TRUE)])))
adjacency_m <- ggplot(plot_df, aes(x = row, y = col)) +
geom_tile(aes(fill = y_prop), color = 'gray30') +
scale_fill_gradient(low = 'grey', high = 'red') +
geom_ysidetile(aes(color = factor(col_z)), show.legend = FALSE, width = 0.5) +
theme_minimal() +
theme(axis.text.x = element_blank(),
axis.text.y = element_blank(),
axis.title.x = element_blank(),
axis.title.y = element_blank(),
legend.position = "bottom", # Position legend below the graph
legend.direction = "horizontal", # Extend legend horizontally,
legend.key.width = unit(1.1, 'cm'),
) +
guides(fill = guide_colorbar(title.position = "top", title.hjust = 0.5)) # Center the title horizontally
adjacency_m
print(adjacency_m)
if(true_model == 'SST'){
ground_truth = list(z = z,
mu_vec_star = mu_vec,
K=K,theta=theta,
model = true_model)
}else if(true_model == 'WST'){
ground_truth = list(z = z,
mu_vec_star = mu_vec,
K=K,
theta=theta,
model = true_model)
}else if(true_model == 'Simple'){
ground_truth = list(z = z,
mu_vec_star = NA,
K=K,
theta=theta,
model = true_model)
}
to_be_saved = list(Y_ij=Y_ij, N_ij =N_ij, ground_truth = ground_truth,
data_plot = adjacency_m,
recovery_capability = recovery_capability,
seed=seed)
saveRDS(to_be_saved, paste0(saving_directory, true_model, K,"_level_recovery",recovery_capability,".RDS"))
}
}
#where the data are stored
data_wd<- "./Data/Sim1_data/"
data_description = 'SST7'
filenames <- list.files(pattern = paste0(data_description),path = data_wd)
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[1]))
recovery_capability = data_to_be_estimated$recovery_capability
N_ij <- data_to_be_estimated$N_ij
n <- nrow(N_ij)
Y_ij <- data_to_be_estimated$Y_ij
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
knitr::opts_chunk$set(echo = TRUE)
read.csv(df_model_choice, "./results/MCMC_output/model_choice/WAIC_method/K7_true/model_choice.csv")
setwd("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/")
read.csv(df_model_choice, "./results/MCMC_output/model_choice/WAIC_method/K7_true/model_choice.csv")
read.csv("./results/MCMC_output/model_choice/WAIC_method/K7_true/model_choice.csv")
setwd("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/")
read.csv("./results/MCMC_output/model_choice/WAIC_method/K7_true/model_choice.csv")
setwd("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/")
read.csv("./results/MCMC_output/model_choice/WAIC_method/K7_true/model_choice.csv")
dir = "/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/"
read.csv(paste0(dir,"/K3_true/model_choice.csv"))
dir = "/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/results/MCMC_output/model_choice/WAIC_method/"
read.csv(paste0(dir,"/K3_true/model_choice.csv"))
read.csv(paste0(dir,"/K3_true/model_choice.csv"),header = T,row.names = 1)
K3_df = read.csv(paste0(dir,"/K3_true/model_choice.csv"),header = T,row.names = 1)
K3_df
library(dplyr)
library(tidyr)
library(ggplot2)
wider_data <- K3_df %>%
pivot_wider(
names_from = est_model,  # The column to use for the new column names
values_from = looic      # The column to use for the values
)
# Print the result
print(wider_data)
wider_data <- K3_df %>%
select(est_model, looic, K_est)
wider_data <- K3_df %>%
select(est_model, looic, K_est)%>%
pivot_wider(
names_from = est_model,  # The column to use for the new column names
values_from = looic      # The column to use for the values
)
# Print the result
print(wider_data)
library(kableExtra)
library(knitr)
min_looic <- min(wider_data[ , -1], na.rm = TRUE)  # Exclude the first column (K_est) for the min search
# Format the table and highlight the minimum looic value
wider_data %>%
mutate(across(where(is.numeric), ~ifelse(. == min_looic, paste0("**", ., "**"), as.character(.)))) %>%
kable("html", escape = FALSE, booktabs = TRUE) %>%
kable_styling(full_width = F)
wider_data <- K3_df %>%
select(est_model, looic, K_est)%>%
pivot_wider(
names_from = est_model,  # The column to use for the new column names
values_from = looic      # The column to use for the values
)%>%
round(2)
min_looic <- min(wider_data[ , -1], na.rm = TRUE)  # Exclude the first column (K_est) for the min search
# Format the table and highlight the minimum looic value
wider_data %>%
mutate(across(where(is.numeric), ~ifelse(. == min_looic, paste0("**", ., "**"), as.character(.)))) %>%
kable("html", escape = FALSE, booktabs = TRUE) %>%
kable_styling(full_width = F)
# Format the table and highlight the minimum looic value
wider_data %>%
mutate(across(where(is.numeric), ~ifelse(. == min_looic, paste0("**", ., "**"), as.character(.)))) %>%
kable("html", escape = FALSE, booktabs = TRUE, caption = "Data were generated from SST = 3") %>%
kable_styling(full_width = F)
K4_df = read.csv(paste0(dir,"/K4_true/model_choice.csv"),header = T,row.names = 1)
wider_data4 <- K4_df %>%
select(est_model, looic, K_est)%>%
pivot_wider(
names_from = est_model,  # The column to use for the new column names
values_from = looic      # The column to use for the values
)%>%
round(2)
min_looic <- min(wider_data4[ , -1], na.rm = TRUE)  # Exclude the first column (K_est) for the min search
# Format the table and highlight the minimum looic value
wider_data4 %>%
mutate(across(where(is.numeric), ~ifelse(. == min_looic, paste0("**", ., "**"), as.character(.)))) %>%
kable("html", escape = FALSE, booktabs = TRUE, caption = "Data were generated from SST = 3") %>%
kable_styling(full_width = F)
# Print the result
K5_df = read.csv(paste0(dir,"/K5_true/model_choice.csv"),header = T,row.names = 1)
wider_data5 <- K5_df %>%
select(est_model, looic, K_est)%>%
pivot_wider(
names_from = est_model,  # The column to use for the new column names
values_from = looic      # The column to use for the values
)%>%
round(2)
min_looic <- min(wider_data5[ , -1], na.rm = TRUE)  # Exclude the first column (K_est) for the min search
# Format the table and highlight the minimum looic value
wider_data5 %>%
mutate(across(where(is.numeric), ~ifelse(. == min_looic, paste0("**", ., "**"), as.character(.)))) %>%
kable("html", escape = FALSE, booktabs = TRUE, caption = "Data were generated from SST = 5") %>%
kable_styling(full_width = F)
# Print the result
K6_df = read.csv(paste0(dir,"/K6_true/model_choice.csv"),header = T,row.names = 1)
wider_data6 <- K6_df %>%
select(est_model, looic, K_est)%>%
pivot_wider(
names_from = est_model,  # The column to use for the new column names
values_from = looic      # The column to use for the values
)%>%
round(2)
min_looic <- min(wider_data6[ , -1], na.rm = TRUE)  # Exclude the first column (K_est) for the min search
# Format the table and highlight the minimum looic value
wider_data6 %>%
mutate(across(where(is.numeric), ~ifelse(. == min_looic, paste0("**", ., "**"), as.character(.)))) %>%
kable("html", escape = FALSE, booktabs = TRUE, caption = "Data were generated from SST = 6") %>%
kable_styling(full_width = F)
K7_df = read.csv(paste0(dir,"/K7_true/model_choice.csv"),header = T,row.names = 1)
wider_data7 <- K7_df %>%
select(est_model, looic, K_est)%>%
pivot_wider(
names_from = est_model,  # The column to use for the new column names
values_from = looic      # The column to use for the values
)%>%
round(2)
min_looic <- min(wider_data7[ , -1], na.rm = TRUE)  # Exclude the first column (K_est) for the min search
# Format the table and highlight the minimum looic value
wider_data7 %>%
mutate(across(where(is.numeric), ~ifelse(. == min_looic, paste0("**", ., "**"), as.character(.)))) %>%
kable("html", escape = FALSE, booktabs = TRUE, caption = "Data were generated from SST = 7") %>%
kable_styling(full_width = F)
knitr::opts_chunk$set(echo = F,eval = T)
# Format the table and highlight the minimum looic value
wider_data %>%
mutate(across(where(is.numeric), ~ifelse(. == min_looic, paste0("**", ., "**"), as.character(.)))) %>%
kable("html", escape = FALSE, booktabs = TRUE, caption = "Data were generated from SST = 3") %>%
kable_styling(full_width = F, position = 'floating_left')
# Format the table and highlight the minimum looic value
wider_data %>%
mutate(across(where(is.numeric), ~ifelse(. == min_looic, paste0("**", ., "**"), as.character(.)))) %>%
kable("html", escape = FALSE, booktabs = TRUE, caption = "Data were generated from SST = 3") %>%
kable_styling(full_width = F, position = 'float_left')
K3_df%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point(size = 2)+
labs(title = "Looic for different models",
subtitle = 'Lower values are better',
caption = paste0("True data ~ ",K3_df$true_model[1], " model ,K = ",K3_df$K_true[1]))
K3_df%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point(size = 2.5)+
labs(title = "Looic for different models",
subtitle = 'Lower values are better',
caption = paste0("True data ~ ",K3_df$true_model[1], " model ,K = ",K3_df$K_true[1]))
K3_df%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point(size = 2.5)+
labs(title = "Looic for different models",
subtitle = 'Lower values are better',
color = "Model"
caption = paste0("True data ~ ",K3_df$true_model[1], " model ,K = ",K3_df$K_true[1]))
K3_df%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point(size = 2.5)+
labs(title = "Looic for different models",
subtitle = 'Lower values are better',
color = "Model",
caption = paste0("True data ~ ",K3_df$true_model[1], " model ,K = ",K3_df$K_true[1]))
K3_df%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point(size = 2.5)+
labs(title = "Looic for different models",
subtitle = 'Lower values are better',
color = "Model",
caption = 'Model',
caption = paste0("True data ~ ",K3_df$true_model[1], " model ,K = ",K3_df$K_true[1]))
K3_df%>%
ggplot(aes(K_est,looic,color = est_model,shape = est_model))+
geom_point(size = 2.5)+
labs(title = "Looic for different models",
subtitle = 'Lower values are better',
color = "Model",
shape = 'Model',
caption = paste0("True data ~ ",K3_df$true_model[1], " model ,K = ",K3_df$K_true[1]))
