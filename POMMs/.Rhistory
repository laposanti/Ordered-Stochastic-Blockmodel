mbar = mbar,
theta =theta_current,
alpha_vec = alpha_vec,
n_k = n_k,
sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,
K = K,
model = model,  t=t)
#--------------------------------------------------------------------------
#setting and initialising containers
#--------------------------------------------------------------------------
#initialising the chain
A_container <- matrix(0, nrow = 1, ncol = N_iter-burnin)
A_container[1] <- A_current
#initialising the chain
z_container <- matrix(0, nrow = n, ncol = N_iter-burnin)
z_container[,1] <- z_current
if(model == 'WST'){
#initialising the chain
sigma_squared_container =  matrix(0, nrow = 1, ncol = N_iter-burnin)
sigma_squared_container[1] <- sigma_squared_current
#initialising the adaptive variance
tau_sigma_squared <- 0.2
tau_sigma_squared_container = matrix(0,1, N_iter)
tau_sigma_squared_container[1] <- tau_sigma_squared
}else{
tau_sigma_squared <- NA
sigma_squared_container <- NA
tau_sigma_squared_container <- NA
}
if(model == 'WST'||model == 'SST'){
#initialising the chain
mu_vec_container = matrix(0, nrow = K+1, ncol = N_iter-burnin)
mu_vec_container[,1] <- mu_vec_current
#initialising the adaptive variance
tau_mu_vec <- 0.1
tau_mu_vec_container = matrix(0,1, N_iter)
tau_mu_vec_container[1] <- tau_mu_vec
}else{
mu_vec_container <- NA
tau_mu_vec <- NA
tau_mu_vec_container <- NA
}
#initialing theta and its adaptive variance container
theta_container = array(0, dim = c(K,K,N_iter-burnin))
theta_container[,,1] <- theta_current
tau_theta_container = array(0,dim=c(K,K,N_iter))
tau_theta =matrix(0.25,K,K)
tau_theta_container[,,1] = tau_theta
#containers for the counts of accepted proposals
acc.count_z = rep(1,n)
acc.count_sigma_squared=1
acc.count_mu_vec = rep(1, K+1)
acc.count_theta<- matrix(1,K,K)
#READY TO BOMB!
iteration_time= vector()
for(j in 2:N_iter){
start_time <- Sys.time()
if (estimation_control$z == 1) {
#z UPDATE-------------------------------------------------------------
z_update = z_update_f(z = z_current, N_ij = N_ij,
Y_ij = Y_ij,theta =theta_current,
lamdabar = lamdabar,ybar=ybar,
mbar=mbar,alpha_vec = alpha_vec,
n_k = n_k,K = K,
acc.count_z = acc.count_z,
labels_available = labels_available,
model, t=t)
lamdabar = z_update$lamdabar
ybar = z_update$ybar
mbar = z_update$mbar
z_current = z_update$z
acc.count_z = z_update$acc.moves
label_counts <- table(factor(z_current, levels = labels_available))
n_k = as.numeric(label_counts)
}
if (estimation_control$theta == 1) {
#theta UPDATE-------------------------------------------------------------
theta_update = theta_update_f(lamdabar = lamdabar,ybar = ybar,mbar = mbar,
theta =theta_current,alpha_vec = alpha_vec,
n_k = n_k,sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K,tau_theta =tau_theta,
acc.count_theta =acc.count_theta,model,t=t)
theta_current = theta_update$theta
acc.count_theta =theta_update$acc.moves
# if(j %% 50 == 0){
#
#   for(my_p in 1:K){
#     for(my_q in my_p:K){
#
#       tau_theta[my_p,my_q] = tuning_proposal(iteration = j,
#                                              acceptance_count = acc.count_theta[my_p,my_q],
#                                              sigma = tau_theta[my_p,my_q],
#                                              acceptanceTarget = optimal_acceptance_rate_theta,
#                                              min_sigma = 0.00002)
#
#     }
#   }
# }
}
if (estimation_control$sigma_squared == 1) {
#sigma_squared UPDATE----------------------------------------------------------------
sigma_squared_update <- sigma_squared_update_f(lamdabar = lamdabar, theta =theta_current,
ybar = ybar,mbar=mbar,
alpha_vec = alpha_vec, n_k = n_k,
sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,
K = K, tau_sigma_squared = tau_sigma_squared,
acc.count_sigma_squared = acc.count_sigma_squared,model,t=t)
#updating quantities
acc.count_sigma_squared = sigma_squared_update$acc.moves
sigma_squared_current = sigma_squared_update$sigma_squared
# if(j %% 50 == 0 ){
#   tau_sigma_squared <- tuning_proposal(iteration=j,
#                                        acceptance_count = acc.count_sigma_squared,
#                                        sigma = tau_sigma_squared,
#                                        acceptanceTarget = optimal_acceptance_rate_theta,
#                                        min_sigma = 0.02)
# }
}
if (estimation_control$mu== 1) {
#mu UPDATE----------------------------------------------------------------
mu_update=  mu_update_f(lamdabar = lamdabar, ybar = ybar,mbar = mbar,  theta =theta_current,
alpha_vec =  alpha_vec, n_k = n_k,
sigma_squared = sigma_squared_current,
mu_vec = mu_vec_current,K = K, tau_mu_vec = tau_mu_vec,
acc.count_mu_vec,model,t=t)
#updating quantities
mu_vec_current = mu_update$mu_vec
acc.count_mu_vec = mu_update$acc.moves
#
# if(j %% 50 == 0){
#   tau_mu_vec <- tuning_proposal(iteration=j,acceptance_count = acc.count_mu_vec,
#                                 sigma = tau_mu_vec,
#                                 acceptanceTarget = optimal_acceptance_rate_mu,
#                                 min_sigma = 0.002)
# }
#
}
#storing scales
# tau_sigma_squared_container[j]<- tau_sigma_squared
# tau_mu_vec_container[j]<- tau_mu_vec
# tau_theta_container[,,j]<- tau_theta
#
#storing results for inference
if(j > burnin){
j_burned = j - burnin
z_container[,j_burned] <- z_current
theta_container[,,j_burned] <- theta_current
if(model == 'WST'){
sigma_squared_container[1,j_burned] = sigma_squared_current
}
if(model == 'WST'|| model=='SST'){
mu_vec_container[,j_burned] <- mu_vec_current
}
A_container[j_burned] =  llik_over_blocks_f_binomial(lamdabar, ybar, mbar, theta_current, K, t=1)
}
# #storing scales
# tau_sigma_squared_container[j]<- tau_sigma_squared
# tau_mu_vec_container[j]<- tau_mu_vec
# tau_theta_container[,,j]<- tau_theta
#
#
end_time <- Sys.time()
iteration_time<-append(iteration_time,as.numeric(difftime(end_time, start_time, units = "secs")))
}
}
acceptance_rates <- list(acc.count_theta = acc.count_theta, acc.count_z = acc.count_z,
acc.count_sigma_squared=acc.count_sigma_squared, acc.count_mu_vec= acc.count_mu_vec)
st.deviations<- list(tau_P = tau_theta_container,
tau_sigma_squared = tau_sigma_squared_container,
tau_mu_vec= tau_mu_vec_container)
est_containers = list(z = z_container,theta = theta_container,
sigma_squared= sigma_squared_container,
mu_vec = mu_vec_container)
control_containers = list(A = A_container)
chains = list(Y_ij= Y_ij, N_ij = N_ij,
seed = seed, ground_truth=ground_truth,est_containers=est_containers,
control_containers=control_containers, acceptance_rates= acceptance_rates,
st.deviations=st.deviations, t=t, seed=seed)
#storing the results of each chain
my_names <- paste0("chain")
where_to_save = saving_directory[[chain]]
my_filename <- paste0(where_to_save,data_description, "Est_model",model,"_estK_",
K,"_N", n, "iteration", which(t == t_list),".RDS")
saveRDS(object = chains, file = my_filename) # saving results
}
acceptance_rates <- list(acc.count_theta =acc.count_theta, acc.count_z = acc.count_z,
acc.count_sigma_squared=acc.count_sigma_squared, acc.count_mu_vec= acc.count_mu_vec)
st.deviations<- list(tau_theta =tau_theta_container,tau_sigma_squared = tau_sigma_squared_container,
tau_mu_vec= tau_mu_vec_container)
est_containers = list(z = z_container,theta = theta_container,
sigma_squared= sigma_squared_container, mu_vec = mu_vec_container)
control_containers = list(A = A_container)
return(list(Y_ij= Y_ij, N_ij = N_ij,
seed = seed, ground_truth=ground_truth,est_containers=est_containers,
control_containers=control_containers, acceptance_rates= acceptance_rates,
st.deviations=st.deviations, t=t, seed=seed))
saving_directory
if(power_posterior_apprach == T){
n_temperatures=50
for(i in 1:length(K_est)){
dir.create(file.path(saving_directory, "/K", K_est[[i]],"//"), showWarnings = FALSE)
}
}
file.path(saving_directory, "/K", K_est[[i]],"//")
file.path(saving_directory, "/", K_est[[i]],"//")
file.path(saving_directory, "K", K_est[[i]],"//")
file.path(saving_directory, "K", K_est[[i]],"/")
file.path(saving_directory, paste0("K", K_est[[i]],"/"))
if(power_posterior_apprach == T){
n_temperatures=50
for(i in 1:length(K_est)){
dir.create(file.path(saving_directory, paste0("K", K_est[[i]],"/")), showWarnings = FALSE)
}
}
if(power_posterior_apprach == T){
n_temperatures=50
for(i in 1:length(K_est)){
dir.create(file.path(saving_directory, paste0("MCMC_output/K", K_est[[i]],"/")), showWarnings = FALSE)
}
}
file.path(saving_directory, paste0("MCMC_output/K", K_est[[i]],"/"))
if(power_posterior_apprach == T){
n_temperatures=50
for(i in 1:length(K_est)){
dir.create(file.path(saving_directory, paste0("MCMC_output/K", K_est[[i]],"/")), showWarnings = FALSE)
}
}
file.path(saving_directory, paste0("MCMC_output/K", K_est[[i]],"/"))
if(power_posterior_apprach == T){
n_temperatures=50
for(i in 1:length(K_est)){
dir.create(file.path(saving_directory, paste0("MCMC_output/K", K_est[[i]],"/")), showWarnings = FALSE)
}
}
length(K_est)
if(power_posterior_apprach == T){
n_temperatures=50
for(i in 1:length(K_est)){
dir.create(file.path(saving_directory, paste0("MCMC_output/K", K_est[[i]],"/")), showWarnings = T)
}
}
dir.create(file.path(saving_directory, paste0("MCMC_output/K", K_est[[i]],"/")), showWarnings = T,
recursive = T)
if(power_posterior_apprach == T){
n_temperatures=50
for(i in 1:length(K_est)){
dir.create(file.path(saving_directory, paste0("MCMC_output/K", K_est[[i]],"/")), showWarnings = T,
recursive = T)
}
}
source("~/Desktop/Nial/POMM_pairwise/POMMs/Model_selectionK3.R", echo=TRUE)
where_to_save = saving_directory[[chain]]
where_to_save
source("~/Desktop/Nial/POMM_pairwise/POMMs/Model_selectionK3.R", echo=TRUE)
K_est[[i]]
K_est
paste0(save_dir,data_description, "Est_model",model,"_estK_",
K,"_N", n, "iteration", which(t == t_list),".RDS")
source("~/Desktop/Nial/POMM_pairwise/POMMs/Model_selectionK3.R", echo=TRUE)
save_dir
chains_seed <- list()
for(i in 1:length(K)){
chains_seed[[i]] = seed + i
}
if(power_posterior_apprach == T){
n_temperatures=50
where_to_save =list()
for(i in 1:length(K_est)){
where_to_save[[i]] =  file.path(saving_directory, paste0("MCMC_output/K", K_est[[i]],"/"))
dir.create(where_to_save[[i]], showWarnings = T, recursive = T)
}
}
n_chains = length(K)
variables_to_add = c('Y_ij', 'N_ij' , 'estimation_control',
'ground_truth','n', 'N_iter','n_chains',
'optimal_acceptance_rate_theta', 'optimal_acceptance_rate_mu', 'K', 'burnin', 'chains_seed','model',
'power_posterior_apprach' ,'true_model', 'custom_init','p','n_temperatures','where_to_save')
set.seed(chains_seed[[chain]])
save_dir = where_to_save[[chain]]
save_dir
#setting hyperparams
K <- as.numeric(K[[chain]])
K
set.seed(chains_seed[[chain]])
save_dir = where_to_save[[chain]]
#setting hyperparams
K <- as.numeric(K_est[[chain]])
K
#where the data are stored
data_wd<- "./Data/power_posterior_data/"
source("~/Desktop/Nial/POMM_pairwise/POMMs/Model_selectionK3.R", echo=TRUE)
chain=2
set.seed(chains_seed[[chain]])
save_dir = where_to_save[[chain]]
chains_seed[[chain]]
#setting up the chain hyperparameter
N_iter <- 12 #number of iterations
burnin <- 2  #number of discarded iterations
K_est = list(2,3,4,5) #number of clusters to fit
n_chains <- length(K_est) #number of chains running in parallel.
n_chains
if(detectCores() < n_chains){
cat('Warning: Number of cores exceeds the ')
}
#where to save the data
saving_directory = "./results/model_selection/"
#Boolean: power_posterior_approach = T estimates the marginal likelihood via power posteriors
power_posterior_apprach = T
custom_init <- NA
print(paste0("Estimation of the SST model, K=", K_est))
print(paste0("Begin cycle at:", date(), "\n"))
seed=23
estimation_control <- list(z = 1, sigma_squared = 0, mu_vec = 1, K = 0, theta = 1)
chains_seed <- list()
for(i in 1:length(K)){
chains_seed[[i]] = seed + i
}
if(power_posterior_apprach == T){
n_temperatures=50
where_to_save =list()
for(i in 1:length(K_est)){
where_to_save[[i]] =  file.path(saving_directory, paste0("MCMC_output/K", K_est[[i]],"/"))
dir.create(where_to_save[[i]], showWarnings = T, recursive = T)
}
}
n_chains = length(K)
n_chains = length(K_est)
n_chains
n_chains = length(K_est)
if(detectCores() < n_chains){
cat('Warning: Number of cores exceeds the ')
}
detectCores()
source("~/Desktop/Nial/POMM_pairwise/POMMs/Model_selectionK3.R", echo=TRUE)
chains_seed <- list()
for(i in 1:length(K_est)){
chains_seed[[i]] = seed + i
}
chains_seed
source("~/Desktop/Nial/POMM_pairwise/POMMs/Model_selectionK3.R", echo=TRUE)
chains_seed <- list()
for(i in 1:length(K_est)){
chains_seed[[i]] = seed + i
}
if(power_posterior_apprach == T){
n_temperatures=50
where_to_save =list()
for(i in 1:length(K_est)){
where_to_save[[i]] =  file.path(saving_directory, paste0("MCMC_output/K", K_est[[i]],"/"))
dir.create(where_to_save[[i]], showWarnings = T, recursive = T)
}
}
n_chains = length(K_est)
if(detectCores() < n_chains){
cat('Warning: Number of cores exceeds the ')
}
set.seed(chains_seed[[chain]])
save_dir = where_to_save[[chain]]
seed
chains_seed
source("~/Desktop/Nial/POMM_pairwise/POMMs/Model_selectionK3.R", echo=TRUE)
data_description
source("~/Desktop/Nial/POMM_pairwise/POMMs/Model_selectionK3.R", echo=TRUE)
source("~/Desktop/Nial/POMM_pairwise/POMMs/Model_selectionK3.R", echo=TRUE)
print(paste0("Estimation of the SST model, K=", K_est))
K_est = list(2,3,4,5,6,7,8) #number of clusters to fit
#where to save the data
saving_directory = "./Results/"
#Boolean: power_posterior_approach = T estimates the marginal likelihood via power posteriors
power_posterior_apprach = T
custom_init <- NA
print(paste0("Estimation of the SST model, K=", K_est))
print(paste0("Begin cycle at:", date(), "\n"))
seed=23
filenames <- list.files(pattern = paste0(data_description),path = data_wd)
# a short description of the data
data_description = 'Citations_application'
Y_ij <- read.csv("./Data/Citations_application/cross-citation-matrix.csv",header = T,row.names = 1)
diag(Y_ij) = 0
N_ij= matrix(0,47,47) +Y_ij*upper.tri(Y_ij)+t(Y_ij)*upper.tri(Y_ij)+Y_ij*lower.tri(Y_ij)+t(Y_ij)*lower.tri(Y_ij)
Y_ij = as.matrix(Y_ij)
N_ij = as.matrix(N_ij)
n <- nrow(N_ij)
Y_ij
is.simulation=F
est_model = 'SST'
#setting up the chain hyperparameter
N_iter <- 120000 #number of iterations
burnin <- 80000  #number of discarded iterations
K_est = list(2,3,4,5,6,7,8) #number of clusters to fit
#where to save the data
saving_directory = "./Results/"
#Boolean: power_posterior_approach = T estimates the marginal likelihood via power posteriors
power_posterior_apprach = T
custom_init <- NA
print(paste0("Estimation of the SST model, K=", K_est))
print(paste0("Begin cycle at:", date(), "\n"))
print(paste0("Estimation of the SST model, K=", K_est))
print(paste0("Estimation of the WST model, K=", K_est))
print(paste0("Begin cycle at:", date(), "\n"))
seed=23
estimation_control <- list(z = 1, sigma_squared = 1, mu_vec = 1, K = 0, theta = 1)
est_model = 'WST'
#setting up the chain hyperparameter
N_iter <- 120000 #number of iterations
burnin <- 80000  #number of discarded iterations
K_est = list(2,3,4,5,6,7,8) #K values to be fitted
#where to save the data
saving_directory = "./Results/"
#Boolean: power_posterior_approach = T estimates the marginal likelihood via power posteriors
power_posterior_apprach = T
#whether you want to initialize the parameters manually
custom_init <- NA
print(paste0("Estimation of the WST model, K=", K_est))
print(paste0("Begin cycle at:", date(), "\n"))
seed=23
estimation_control <- list(z = 1, sigma_squared = 1, mu_vec = 1, K = 0, theta = 1)
names(chains) = paste0('chain',unlist(K_est))
#----------------------------------
#setting chains' features
#setting up the chain hyperparameter
N_iter <- 120000 #number of iterations
source("~/Desktop/Nial/POMM_pairwise/POMMs/Application_launcherWST_Citations.R", echo=TRUE)
print(paste0("Estimation of the", est_model ,"model, K=", K_est))
print(paste0("Estimation of the ", est_model ,"model, K=", K_est))
print(paste0("Estimation of the ", est_model ," model, K=", K_est))
#--------------------------------
#which model to fit
est_model = 'SST'
#which parameters to estimate: 1 estimated, 0 fixed. if 0 is selected, provide some initial quantity
estimation_control <- list(z = 1, sigma_squared = 1, mu_vec = 1, K = 0, theta = 1)
#which parameters to estimate: 1 estimated, 0 fixed. if 0 is selected, provide some initial quantity
estimation_control <- list(z = 1, sigma_squared = 0, mu_vec = 1, K = 0, theta = 1)
custom_init <- NA #whether you want to initialize the parameters manually
N_iter <- 120000 #number of iterations
burnin <- 80000  #number of discarded iterations
K_est = list(2,3,4,5,6,7,8) #K values to be fitted
power_posterior_apprach = T #Boolean: power_posterior_approach = T estimates the marginal likelihood via power posteriors
seed=23 #the seed for the chains
#----------------------------------
#where to save the data
saving_directory = "./Results/"
print(paste0("Estimation of the ", est_model ," model, K=", K_est))
print(paste0("Begin cycle at:", date(), "\n"))
print(paste0("Estimation of the", est_model," model, K=", K_est))
print(paste0("Estimation of the ", est_model," model, K=", K_est))
where_to_save[[i]] =  file.path(saving_directory, paste0("model_selection/MCMC_output/",data_description,"/",model,"/K", K_est[[i]],"/"))
where_to_save
#where the data are stored
data_wd<- "./Data/power_posterior_data/"
data_description = 'SST'
filenames <- list.files(pattern = paste0(data_description),path = data_wd)
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[2]))
N_ij <- data_to_be_estimated$N_ij
n <- nrow(N_ij)
Y_ij <- data_to_be_estimated$Y_ij
K <- data_to_be_estimated$ground_truth$K
ground_truth <- data_to_be_estimated$ground_truth
print(paste0("True data--->", filenames[1], "\n"))
K
source("~/Desktop/Nial/POMM_pairwise/POMMs/model_auxiliary_functions/reading_resultS.R", echo=TRUE)
source("~/Desktop/Nial/POMM_pairwise/POMMs/Application_laucher.R", echo=TRUE)
source("~/Desktop/Nial/POMM_pairwise/POMMs/Application_laucher.R", echo=TRUE)
source("~/Desktop/Nial/POMM_pairwise/POMMs/Application_launcherWST_Citations.R", echo=TRUE)
source("~/Desktop/Nial/POMM_pairwise/POMMs/Application_launcherWST_Citations.R", echo=TRUE)
source("~/Desktop/Nial/POMM_pairwise/POMMs/Application_laucherSST_Citations.R", echo=TRUE)
source("~/Desktop/Nial/POMM_pairwise/POMMs/Application_laucherSimple_Citations.R", echo=TRUE)
print(paste0("True data--->", filenames[1], "\n"))
is.simulation=T
est_model = 'Simple'
#where the data are stored
data_wd<- "./Data/power_posterior_data/"
data_description = 'SST_K3'
filenames <- list.files(pattern = paste0(data_description),path = data_wd)
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[1]))
filenames <- list.files(pattern = paste0('SST'),path = data_wd)
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[1]))
N_ij <- data_to_be_estimated$N_ij
data_wd
filenames <- list.files(pattern = paste0('SST'),path = data_wd)
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[1]))
#where the data are stored
data_wd<- "./Data/power_posterior_data/"
data_description = 'SST_K3'
filenames <- list.files(pattern = paste0('SST'),path = data_wd)
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[1]))
N_ij <- data_to_be_estimated$N_ij
n <- nrow(N_ij)
Y_ij <- data_to_be_estimated$Y_ij
K <- data_to_be_estimated$ground_truth$K
ground_truth <- data_to_be_estimated$ground_truth
data_description = 'SST6'
filenames <- list.files(pattern = paste0(data_description),path = data_wd)
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[4]))
N_ij <- data_to_be_estimated$N_ij
#where the data are stored
data_wd<- "./Data/power_posterior_data/"
data_description = 'SST6'
filenames <- list.files(pattern = paste0(data_description),path = data_wd)
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[4]))
data_wd
getwd()
#where the data are stored
data_wd<- "./Data/power_posterior_data/"
data_description = 'SST6'
filenames <- list.files(pattern = paste0(data_description),path = data_wd)
filenames
data_description = 'SST5'
filenames <- list.files(pattern = paste0(data_description),path = data_wd)
data_to_be_estimated <- readRDS(paste0(data_wd, "/", filenames[1]))
