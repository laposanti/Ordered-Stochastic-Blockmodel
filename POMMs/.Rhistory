theme_bw()
data.frame(iteration = j+burnin,
mu = uploaded_results$chain1$est_containers$mu_vec[,j],
entry = factor(1:(K+1)))
mu_vec_df <- do.call(rbind, lapply(1:(N_iter-burnin), function(j) {
data.frame(iteration = j+burnin,
mu = uploaded_results$chain1$est_containers$mu_vec[,j],
entry = factor(1:(K+1)))
}))
ggplot(mu_vec_df, aes(x = iteration, color = entry, group=entry))+
geom_line(aes(y=mu), alpha=.3)+
theme_bw()
apply(uploaded_results$chain1$acceptance_rates$acc.count_mu_vec, 2 , sum)
uploaded_results$chain1$acceptance_rates$acc.count_mu_vec
P_est_relabeled - theta_init
source("~/Desktop/Nial/POMM_pairwise/POMMs/model_auxiliary_functions/MCMC_functions.R")
source("~/Desktop/Nial/POMM_pairwise/POMMs/model_auxiliary_functions/MCMC_functions.R")
library(doFuture)
library(progressr)
library(beepr)
library(foreach)
library(doParallel)
library(tidyverse)
library(EnvStats)
library(truncnorm)
library(dplyr)
library(ggplot2)
library(dplyr)
library(RColorBrewer)
library(truncnorm)
library(doRNG)
setwd("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/")
source("./model_auxiliary_functions/Functions_priorSST.R")
source("./Metropolis_within_Gibbs_code.R")
source("./model_auxiliary_functions/MCMC_functions.R")
n_chains = 4
optimal_acceptance_rate_theta =.44
optimal_acceptance_rate_mu = .234
N_iter= 10000
burnin= 5000
chains_seeds = list(20,21,22,23)
chains_SST = adaptive_MCMC_orderstats(Y_ij = Y_ij, N_ij = N_ij ,
estimation_control = estimation_control,  burnin = burnin,
ground_truth = ground_truth,
n = n, N_iter = N_iter,n_chains = n_chains, optimal_acceptance_rate_theta = optimal_acceptance_rate_theta,
optimal_acceptance_rate_mu = optimal_acceptance_rate_mu,
K = K_chains,
seed = chains_seeds, model = 'SST', t= t_chains,
custom_init = NA)
my_names <- paste0("chain", 1:n_chains)
names(chains_SST)<-my_names
uploaded_results <- chains_SST
print(paste0('Now estimating ', filenames[file]))
print(paste0(length(filenames)-file+1,' within the same class left '))
N= nrow(uploaded_results$chain1$Y_ij)
n=N
N_iter = dim(uploaded_results$chain1$est_containers$z)[[2]]
K = dim(uploaded_results$chain1$est_containers$theta)[[1]]
burnin = max(N_iter - 40000,1)
Y_ij <- uploaded_results$chain1$Y_ij
N_ij <- uploaded_results$chain1$N_ij
#-------------------------------------------------------------------------------
# P temporary estimate
#-------------------------------------------------------------------------------
P_burned = uploaded_results$chain1$est_containers$theta[,,-c(1:burnin)]
z_burned =  uploaded_results$chain1$est_containers$z[,-c(1:burnin)]
if(est_model != 'Simple'){
m_vec_burned = uploaded_results$chain1$est_containers$mu_vec[,-c(1:burnin)]
}
if(est_model == 'WST'){
sigma_squared_burned = uploaded_results$chain1$est_containers$sigma_squared[-c(1:burnin)]
}
theta = apply(P_burned, c(1,2), mean)
P_est = inverse_logit_f(theta)
my_z_est<- z_plot(z_burned = z_burned,  A = uploaded_results$chain1$control_containers$A[-c(1:burnin)],Y_ij = Y_ij, N_ij = N_ij, true_model= true_model,P_est = P_est,
est_model = est_model, true_value =is.simulation,
diag0.5 =diag0.5 , K=K, N=nrow(uploaded_results$chain1$Y_ij), z_true = uploaded_results$chain1$ground_truth$z ,
burnin =  burnin ,label_switch = T,tap= processed_wd)
point_est_z<- as.vector(my_z_est$point_est)
table(point_est_z)
K_est<- length(unique(point_est_z))
permutations_z<- my_z_est$permutations
z_chain_permuted<- my_z_est$relabeled_chain
P_s_table <- P_summary_table(P_burned = P_burned,
true_value = is.simulation,
permutations_z = permutations_z,
diag0.5 = TRUE,
K = K, P_true = uploaded_results$chain1$ground_truth$theta,
burnin = burnin,
label_switch = T)
P_s_table_save <-P_s_table$table
theta_chain_permuted <- P_s_table$P_permuted
P_est_relabeled<- P_s_table$P_hat
inverse_logit_f(P_est_relabeled)
#some traceplots
upper_tri_indices= which(upper.tri(P_est_relabeled, diag=T),arr.ind = T)
if(is.simulation ==T){
P_trace_df_post_switch <- do.call(rbind, lapply(1:(N_iter-burnin), function(j) {
data.frame(iteration = j,
theta = upper.tri.extractor(theta_chain_permuted[,,j]),
theta_true = upper.tri.extractor(uploaded_results$chain1$ground_truth$theta),
entry = paste0(upper_tri_indices[,1], upper_tri_indices[,2]))
}))
P_trace_df_post_switch=P_trace_df_post_switch%>% mutate(P = inverse_logit_f(theta))%>%
mutate(P_true = inverse_logit_f(theta_true))
traceplot_P = ggplot(P_trace_df_post_switch, aes(x = iteration, color = entry, group=entry))+
geom_line(aes(y=P), alpha=.3)+
geom_line(aes(y=P_true), linetype=2, color='red')+
facet_wrap(~entry)+
theme_bw()
}else if(is.simulation ==F){
P_trace_df_post_switch <- do.call(rbind, lapply(1:(N_iter-burnin), function(j) {
data.frame(iteration = j+burnin,
theta = upper.tri.extractor(theta_chain_permuted[,,j]),
entry = paste0(upper_tri_indices[,1], upper_tri_indices[,2]))
}))
P_trace_df_post_switch=P_trace_df_post_switch%>% mutate(P = inverse_logit_f(theta))
traceplot_P = ggplot(P_trace_df_post_switch, aes(x = iteration, color = entry, group=entry))+
geom_line(aes(y=P), alpha=.3)+
facet_wrap(~entry)+
theme_bw()
}
mu_vec_df <- do.call(rbind, lapply(1:(N_iter-burnin), function(j) {
data.frame(iteration = j+burnin,
mu = uploaded_results$chain1$est_containers$mu_vec[,j],
entry = factor(1:(K+1)))
}))
ggplot(mu_vec_df, aes(x = iteration, color = entry, group=entry))+
geom_line(aes(y=mu), alpha=.3)+
theme_bw()
traceplot_P
source("~/Desktop/Nial/POMM_pairwise/POMMs/Metropolis_within_Gibbs_code.R")
source("~/Desktop/Nial/POMM_pairwise/POMMs/model_auxiliary_functions/MCMC_functions.R")
library(doFuture)
library(progressr)
library(beepr)
library(foreach)
library(doParallel)
library(tidyverse)
library(EnvStats)
library(truncnorm)
library(dplyr)
library(ggplot2)
library(dplyr)
library(RColorBrewer)
library(truncnorm)
library(doRNG)
setwd("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/")
source("./model_auxiliary_functions/Functions_priorSST.R")
source("./Metropolis_within_Gibbs_code.R")
source("./model_auxiliary_functions/MCMC_functions.R")
n_chains = 4
optimal_acceptance_rate_theta =.44
optimal_acceptance_rate_mu = .234
N_iter= 10000
burnin= 5000
chains_seeds = list(20,21,22,23)
estimation_control = list(z = 1,sigma_squared=0, mu_vec=1,K=0,theta=1)
K_chains = list(k_th,k_th,k_th,k_th)
t_chains = rep(1,n_chains)
P_init = read_csv('/Users/lapo_santi/Desktop/Nial/MCMC_results/application_13Feb2024/tennis/estimates/P_est_matrixTennis_dataSST5.csv',
col_names = T)
theta_init = as.matrix(P_init[,-1])
P_est_relabeled - theta_init
ground_truth = list(theta = theta_init,
mu_vec =mu_vec)
P_est_relabeled
theta_init
theta_init
ground_truth = list(theta = theta_init,
mu_vec =mu_vec)
chains_SST = adaptive_MCMC_orderstats(Y_ij = Y_ij, N_ij = N_ij ,
estimation_control = estimation_control,  burnin = burnin,
ground_truth = ground_truth,
n = n, N_iter = N_iter,n_chains = n_chains, optimal_acceptance_rate_theta = optimal_acceptance_rate_theta,
optimal_acceptance_rate_mu = optimal_acceptance_rate_mu,
K = K_chains,
seed = chains_seeds, model = 'SST', t= t_chains,
custom_init = NA)
my_names <- paste0("chain", 1:n_chains)
names(chains_SST)<-my_names
uploaded_results <- chains_SST
print(paste0('Now estimating ', filenames[file]))
print(paste0(length(filenames)-file+1,' within the same class left '))
N= nrow(uploaded_results$chain1$Y_ij)
n=N
N_iter = dim(uploaded_results$chain1$est_containers$z)[[2]]
K = dim(uploaded_results$chain1$est_containers$theta)[[1]]
burnin = max(N_iter - 40000,1)
Y_ij <- uploaded_results$chain1$Y_ij
N_ij <- uploaded_results$chain1$N_ij
#-------------------------------------------------------------------------------
# P temporary estimate
#-------------------------------------------------------------------------------
P_burned = uploaded_results$chain1$est_containers$theta[,,-c(1:burnin)]
z_burned =  uploaded_results$chain1$est_containers$z[,-c(1:burnin)]
if(est_model != 'Simple'){
m_vec_burned = uploaded_results$chain1$est_containers$mu_vec[,-c(1:burnin)]
}
if(est_model == 'WST'){
sigma_squared_burned = uploaded_results$chain1$est_containers$sigma_squared[-c(1:burnin)]
}
theta = apply(P_burned, c(1,2), mean)
P_est = inverse_logit_f(theta)
my_z_est<- z_plot(z_burned = z_burned,  A = uploaded_results$chain1$control_containers$A[-c(1:burnin)],Y_ij = Y_ij, N_ij = N_ij, true_model= true_model,P_est = P_est,
est_model = est_model, true_value =is.simulation,
diag0.5 =diag0.5 , K=K, N=nrow(uploaded_results$chain1$Y_ij), z_true = uploaded_results$chain1$ground_truth$z ,
burnin =  burnin ,label_switch = T,tap= processed_wd)
point_est_z<- as.vector(my_z_est$point_est)
table(point_est_z)
K_est<- length(unique(point_est_z))
permutations_z<- my_z_est$permutations
z_chain_permuted<- my_z_est$relabeled_chain
P_s_table <- P_summary_table(P_burned = P_burned,
true_value = is.simulation,
permutations_z = permutations_z,
diag0.5 = TRUE,
K = K, P_true = uploaded_results$chain1$ground_truth$theta,
burnin = burnin,
label_switch = T)
P_s_table_save <-P_s_table$table
theta_chain_permuted <- P_s_table$P_permuted
P_est_relabeled<- P_s_table$P_hat
inverse_logit_f(P_est_relabeled)
#some traceplots
upper_tri_indices= which(upper.tri(P_est_relabeled, diag=T),arr.ind = T)
if(is.simulation ==T){
P_trace_df_post_switch <- do.call(rbind, lapply(1:(N_iter-burnin), function(j) {
data.frame(iteration = j,
theta = upper.tri.extractor(theta_chain_permuted[,,j]),
theta_true = upper.tri.extractor(uploaded_results$chain1$ground_truth$theta),
entry = paste0(upper_tri_indices[,1], upper_tri_indices[,2]))
}))
P_trace_df_post_switch=P_trace_df_post_switch%>% mutate(P = inverse_logit_f(theta))%>%
mutate(P_true = inverse_logit_f(theta_true))
traceplot_P = ggplot(P_trace_df_post_switch, aes(x = iteration, color = entry, group=entry))+
geom_line(aes(y=P), alpha=.3)+
geom_line(aes(y=P_true), linetype=2, color='red')+
facet_wrap(~entry)+
theme_bw()
}else if(is.simulation ==F){
P_trace_df_post_switch <- do.call(rbind, lapply(1:(N_iter-burnin), function(j) {
data.frame(iteration = j+burnin,
theta = upper.tri.extractor(theta_chain_permuted[,,j]),
entry = paste0(upper_tri_indices[,1], upper_tri_indices[,2]))
}))
P_trace_df_post_switch=P_trace_df_post_switch%>% mutate(P = inverse_logit_f(theta))
traceplot_P = ggplot(P_trace_df_post_switch, aes(x = iteration, color = entry, group=entry))+
geom_line(aes(y=P), alpha=.3)+
facet_wrap(~entry)+
theme_bw()
}
mu_vec_df <- do.call(rbind, lapply(1:(N_iter-burnin), function(j) {
data.frame(iteration = j+burnin,
mu = uploaded_results$chain1$est_containers$mu_vec[,j],
entry = factor(1:(K+1)))
}))
ggplot(mu_vec_df, aes(x = iteration, color = entry, group=entry))+
geom_line(aes(y=mu), alpha=.3)+
theme_bw()
source("~/Desktop/Nial/POMM_pairwise/POMMs/Metropolis_within_Gibbs_code.R")
p_proposal_current = dtruncnorm(mu_vec[mu],a = lbs[mu],b = ubs[mu], mean = mu_1_K_prime,sd = 1)
#evaluating the proposal density g(mu'| mu^(t))
p_proposal_prime = dtruncnorm(mu_1_K_prime,a = lbs[mu],b = ubs[mu], mean = mu_vec[mu],sd = 1)
library(doFuture)
library(progressr)
library(beepr)
library(foreach)
library(doParallel)
library(tidyverse)
library(EnvStats)
library(truncnorm)
library(dplyr)
library(ggplot2)
library(dplyr)
library(RColorBrewer)
library(truncnorm)
library(doRNG)
setwd("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/")
source("./model_auxiliary_functions/Functions_priorSST.R")
source("./Metropolis_within_Gibbs_code.R")
source("./model_auxiliary_functions/MCMC_functions.R")
ground_truth = list(theta = theta_init,
mu_vec =mu_vec)
chains_SST = adaptive_MCMC_orderstats(Y_ij = Y_ij, N_ij = N_ij ,
estimation_control = estimation_control,  burnin = burnin,
ground_truth = ground_truth,
n = n, N_iter = N_iter,n_chains = n_chains, optimal_acceptance_rate_theta = optimal_acceptance_rate_theta,
optimal_acceptance_rate_mu = optimal_acceptance_rate_mu,
K = K_chains,
seed = chains_seeds, model = 'SST', t= t_chains,
custom_init = NA)
my_names <- paste0("chain", 1:n_chains)
names(chains_SST)<-my_names
uploaded_results <- chains_SST
print(paste0('Now estimating ', filenames[file]))
print(paste0(length(filenames)-file+1,' within the same class left '))
N= nrow(uploaded_results$chain1$Y_ij)
n=N
N_iter = dim(uploaded_results$chain1$est_containers$z)[[2]]
K = dim(uploaded_results$chain1$est_containers$theta)[[1]]
burnin = max(N_iter - 40000,1)
Y_ij <- uploaded_results$chain1$Y_ij
N_ij <- uploaded_results$chain1$N_ij
#-------------------------------------------------------------------------------
# P temporary estimate
#-------------------------------------------------------------------------------
P_burned = uploaded_results$chain1$est_containers$theta[,,-c(1:burnin)]
z_burned =  uploaded_results$chain1$est_containers$z[,-c(1:burnin)]
if(est_model != 'Simple'){
m_vec_burned = uploaded_results$chain1$est_containers$mu_vec[,-c(1:burnin)]
}
if(est_model == 'WST'){
sigma_squared_burned = uploaded_results$chain1$est_containers$sigma_squared[-c(1:burnin)]
}
theta = apply(P_burned, c(1,2), mean)
P_est = inverse_logit_f(theta)
my_z_est<- z_plot(z_burned = z_burned,  A = uploaded_results$chain1$control_containers$A[-c(1:burnin)],Y_ij = Y_ij, N_ij = N_ij, true_model= true_model,P_est = P_est,
est_model = est_model, true_value =is.simulation,
diag0.5 =diag0.5 , K=K, N=nrow(uploaded_results$chain1$Y_ij), z_true = uploaded_results$chain1$ground_truth$z ,
burnin =  burnin ,label_switch = T,tap= processed_wd)
point_est_z<- as.vector(my_z_est$point_est)
table(point_est_z)
K_est<- length(unique(point_est_z))
permutations_z<- my_z_est$permutations
z_chain_permuted<- my_z_est$relabeled_chain
P_s_table <- P_summary_table(P_burned = P_burned,
true_value = is.simulation,
permutations_z = permutations_z,
diag0.5 = TRUE,
K = K, P_true = uploaded_results$chain1$ground_truth$theta,
burnin = burnin,
label_switch = T)
P_s_table_save <-P_s_table$table
theta_chain_permuted <- P_s_table$P_permuted
P_est_relabeled<- P_s_table$P_hat
inverse_logit_f(P_est_relabeled)
#some traceplots
upper_tri_indices= which(upper.tri(P_est_relabeled, diag=T),arr.ind = T)
if(is.simulation ==T){
P_trace_df_post_switch <- do.call(rbind, lapply(1:(N_iter-burnin), function(j) {
data.frame(iteration = j,
theta = upper.tri.extractor(theta_chain_permuted[,,j]),
theta_true = upper.tri.extractor(uploaded_results$chain1$ground_truth$theta),
entry = paste0(upper_tri_indices[,1], upper_tri_indices[,2]))
}))
P_trace_df_post_switch=P_trace_df_post_switch%>% mutate(P = inverse_logit_f(theta))%>%
mutate(P_true = inverse_logit_f(theta_true))
traceplot_P = ggplot(P_trace_df_post_switch, aes(x = iteration, color = entry, group=entry))+
geom_line(aes(y=P), alpha=.3)+
geom_line(aes(y=P_true), linetype=2, color='red')+
facet_wrap(~entry)+
theme_bw()
}else if(is.simulation ==F){
P_trace_df_post_switch <- do.call(rbind, lapply(1:(N_iter-burnin), function(j) {
data.frame(iteration = j+burnin,
theta = upper.tri.extractor(theta_chain_permuted[,,j]),
entry = paste0(upper_tri_indices[,1], upper_tri_indices[,2]))
}))
P_trace_df_post_switch=P_trace_df_post_switch%>% mutate(P = inverse_logit_f(theta))
traceplot_P = ggplot(P_trace_df_post_switch, aes(x = iteration, color = entry, group=entry))+
geom_line(aes(y=P), alpha=.3)+
facet_wrap(~entry)+
theme_bw()
}
mu_vec_df <- do.call(rbind, lapply(1:(N_iter-burnin), function(j) {
data.frame(iteration = j+burnin,
mu = uploaded_results$chain1$est_containers$mu_vec[,j],
entry = factor(1:(K+1)))
}))
ggplot(mu_vec_df, aes(x = iteration, color = entry, group=entry))+
geom_line(aes(y=mu), alpha=.3)+
theme_bw()
traceplot_P
theta
P_s_table_save <-P_s_table$table
theta_chain_permuted <- P_s_table$P_permuted
P_est_relabeled<- P_s_table$P_hat
P_est_relabeled
ggplot(mu_vec_df, aes(x = iteration, color = entry, group=entry))+
geom_line(aes(y=mu), alpha=.3)+
theme_bw()
mu_vec_df %>% group_by(entry) %>%
summarise(mean = mean,
quantile5 = quantile(probs = 0.05),
quantile95 = qunatile(probs = 0.95))
mu_vec_df %>% group_by(entry) %>%
summarise_all(mean = mean,
quantile5 = quantile(probs = 0.05),
quantile95 = qunatile(probs = 0.95))
mu_vec_df %>% group_by(entry) %>%
summarise(mean = mean(mu),
quantile5 = quantile(probs = 0.05, x = mu),
quantile95 = qunatile(probs = 0.95, x = mu))
mu_vec_df %>% group_by(entry) %>%
summarise(mean = mean(mu),
quantile5 = quantile(probs = 0.05, x = mu),
quantile95 = quantile(probs = 0.95, x = mu))
source("~/Desktop/Nial/POMM_pairwise/POMMs/model_auxiliary_functions/MCMC_functions.R")
setwd("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/")
source("./model_auxiliary_functions/Functions_priorSST.R")
source("./Metropolis_within_Gibbs_code.R")
source("./model_auxiliary_functions/MCMC_functions.R")
n_chains = 4
optimal_acceptance_rate_theta =.44
optimal_acceptance_rate_mu = .234
N_iter= 10000
burnin= 5000
chains_seeds = list(20,21,22,23)
ground_truth = list(theta = theta_init,
mu_vec =mu_vec)
chains_SST = adaptive_MCMC_orderstats(Y_ij = Y_ij, N_ij = N_ij ,
estimation_control = estimation_control,  burnin = burnin,
ground_truth = ground_truth,
n = n, N_iter = N_iter,n_chains = n_chains, optimal_acceptance_rate_theta = optimal_acceptance_rate_theta,
optimal_acceptance_rate_mu = optimal_acceptance_rate_mu,
K = K_chains,
seed = chains_seeds, model = 'SST', t= t_chains,
custom_init = NA)
my_names <- paste0("chain", 1:n_chains)
names(chains_SST)<-my_names
uploaded_results <- chains_SST
print(paste0('Now estimating ', filenames[file]))
print(paste0(length(filenames)-file+1,' within the same class left '))
N= nrow(uploaded_results$chain1$Y_ij)
n=N
N_iter = dim(uploaded_results$chain1$est_containers$z)[[2]]
K = dim(uploaded_results$chain1$est_containers$theta)[[1]]
burnin = max(N_iter - 40000,1)
Y_ij <- uploaded_results$chain1$Y_ij
N_ij <- uploaded_results$chain1$N_ij
#-------------------------------------------------------------------------------
# P temporary estimate
#-------------------------------------------------------------------------------
P_burned = uploaded_results$chain1$est_containers$theta[,,-c(1:burnin)]
z_burned =  uploaded_results$chain1$est_containers$z[,-c(1:burnin)]
if(est_model != 'Simple'){
m_vec_burned = uploaded_results$chain1$est_containers$mu_vec[,-c(1:burnin)]
}
if(est_model == 'WST'){
sigma_squared_burned = uploaded_results$chain1$est_containers$sigma_squared[-c(1:burnin)]
}
theta = apply(P_burned, c(1,2), mean)
P_est = inverse_logit_f(theta)
my_z_est<- z_plot(z_burned = z_burned,  A = uploaded_results$chain1$control_containers$A[-c(1:burnin)],Y_ij = Y_ij, N_ij = N_ij, true_model= true_model,P_est = P_est,
est_model = est_model, true_value =is.simulation,
diag0.5 =diag0.5 , K=K, N=nrow(uploaded_results$chain1$Y_ij), z_true = uploaded_results$chain1$ground_truth$z ,
burnin =  burnin ,label_switch = T,tap= processed_wd)
point_est_z<- as.vector(my_z_est$point_est)
table(point_est_z)
K_est<- length(unique(point_est_z))
permutations_z<- my_z_est$permutations
z_chain_permuted<- my_z_est$relabeled_chain
P_s_table <- P_summary_table(P_burned = P_burned,
true_value = is.simulation,
permutations_z = permutations_z,
diag0.5 = TRUE,
K = K, P_true = uploaded_results$chain1$ground_truth$theta,
burnin = burnin,
label_switch = T)
P_s_table_save <-P_s_table$table
theta_chain_permuted <- P_s_table$P_permuted
P_est_relabeled<- P_s_table$P_hat
inverse_logit_f(P_est_relabeled)
#some traceplots
upper_tri_indices= which(upper.tri(P_est_relabeled, diag=T),arr.ind = T)
if(is.simulation ==T){
P_trace_df_post_switch <- do.call(rbind, lapply(1:(N_iter-burnin), function(j) {
data.frame(iteration = j,
theta = upper.tri.extractor(theta_chain_permuted[,,j]),
theta_true = upper.tri.extractor(uploaded_results$chain1$ground_truth$theta),
entry = paste0(upper_tri_indices[,1], upper_tri_indices[,2]))
}))
P_trace_df_post_switch=P_trace_df_post_switch%>% mutate(P = inverse_logit_f(theta))%>%
mutate(P_true = inverse_logit_f(theta_true))
traceplot_P = ggplot(P_trace_df_post_switch, aes(x = iteration, color = entry, group=entry))+
geom_line(aes(y=P), alpha=.3)+
geom_line(aes(y=P_true), linetype=2, color='red')+
facet_wrap(~entry)+
theme_bw()
}else if(is.simulation ==F){
P_trace_df_post_switch <- do.call(rbind, lapply(1:(N_iter-burnin), function(j) {
data.frame(iteration = j+burnin,
theta = upper.tri.extractor(theta_chain_permuted[,,j]),
entry = paste0(upper_tri_indices[,1], upper_tri_indices[,2]))
}))
P_trace_df_post_switch=P_trace_df_post_switch%>% mutate(P = inverse_logit_f(theta))
traceplot_P = ggplot(P_trace_df_post_switch, aes(x = iteration, color = entry, group=entry))+
geom_line(aes(y=P), alpha=.3)+
facet_wrap(~entry)+
theme_bw()
}
traceplot_P
mu_vec_df <- do.call(rbind, lapply(1:(N_iter-burnin), function(j) {
data.frame(iteration = j+burnin,
mu = uploaded_results$chain1$est_containers$mu_vec[,j],
entry = factor(1:(K+1)))
}))
ggplot(mu_vec_df, aes(x = iteration, color = entry, group=entry))+
geom_line(aes(y=mu), alpha=.3)+
theme_bw()
mu_0_lp = dnorm(mu_vec[1],0,1,log=T)
#mu prior distribution
d_sA_mu = function(K,mu_vec){
mu_0_lp = dnorm(mu_vec[1],0,1,log=T)
fac <- lfactorial(K)
joint_density<- sum(log(dtruncnorm(mu_vec[2:(K+1)],a = 0,mean = 0,sd = 3)) -
log(1- pnorm(0,mean = 0,sd = 3)))
return(joint_density+fac+mu_0_lp)
}
source("~/Desktop/Nial/POMM_pairwise/POMMs/model_auxiliary_functions/MCMC_functions.R")
source("~/Desktop/Nial/POMM_pairwise/POMMs/model_auxiliary_functions/reading_resultS.R")
