}
# Generate example data
set.seed(123)
N <- 1000
K <- 5
z_scanning_mat <- matrix(0, nrow = N, ncol = K)
for(i in 1:N){
cluster = sample(c(1:K),size = 1)
z_scanning_mat[i,cluster] = 1
}
P_matrix <- matrix(runif(K*K), nrow = K, ncol = K)
# Calculate victory probabilities using Option 1 (Original)
p_ij_scanning_original <- calculate_victory_probabilities_original(z_scanning_mat, P_matrix)
# Calculate victory probabilities using Option 2 (Modified)
p_ij_scanning_modified <- calculate_victory_probabilities_modified1(as.matrix(z_scanning_mat), P_matrix)
# Verify that the results are the same
identical(p_ij_scanning_original, p_ij_scanning_modified)  # Should return TRUE
calculate_victory_probabilities_modified1 <- function(z_mat, P) {
K <- ncol(z_mat)
N <- nrow(z_mat)
p_ij_scanning <- matrix(0, N, N)
for (i in 1:(N-1)) {
for (j in (i+1):N) {
cluster_i <- which(z_mat[i, ]>0)
cluster_j <- which(z_mat[j, ]>0)
p_ij_scanning[i, j] <- P[cbind(cluster_i, cluster_j))
calculate_victory_probabilities_modified1 <- function(z_mat, P) {
K <- ncol(z_mat)
N <- nrow(z_mat)
p_ij_scanning <- matrix(0, N, N)
for (i in 1:(N-1)) {
for (j in (i+1):N) {
cluster_i <- which(z_mat[i, ]>0)
cluster_j <- which(z_mat[j, ]>0)
p_ij_scanning[i, j] <- P[cbind(cluster_i, cluster_j)]
p_ij_scanning[j, i] <- 1 - p_ij_scanning[i, j]
}
}
return(p_ij_scanning)
}
# Generate example data
set.seed(123)
N <- 1000
K <- 5
z_scanning_mat <- matrix(0, nrow = N, ncol = K)
for(i in 1:N){
cluster = sample(c(1:K),size = 1)
z_scanning_mat[i,cluster] = 1
}
P_matrix <- matrix(runif(K*K), nrow = K, ncol = K)
# Calculate victory probabilities using Option 1 (Original)
p_ij_scanning_original <- calculate_victory_probabilities_original(z_scanning_mat, P_matrix)
# Calculate victory probabilities using Option 2 (Modified)
p_ij_scanning_modified <- calculate_victory_probabilities_modified1(as.matrix(z_scanning_mat), P_matrix)
# Verify that the results are the same
identical(p_ij_scanning_original, p_ij_scanning_modified)  # Should return TRUE
P_matrix<-semi_symmetric(P_matrix)
P_matrix
diag(P_matrix)<- 0.5
# Calculate victory probabilities using Option 1 (Original)
p_ij_scanning_original <- calculate_victory_probabilities_original(z_scanning_mat, P_matrix)
# Calculate victory probabilities using Option 2 (Modified)
p_ij_scanning_modified <- calculate_victory_probabilities_modified1(as.matrix(z_scanning_mat), P_matrix)
# Verify that the results are the same
identical(p_ij_scanning_original, p_ij_scanning_modified)  # Should return TRUE
# Calculate victory probabilities using Option 1 (Original)
p_ij_scanning_original <- calculate_victory_probabilities_original(z_scanning_mat, P_matrix)
# Calculate victory probabilities using Option 2 (Modified)
p_ij_scanning_modified <- calculate_victory_probabilities_modified(as.matrix(z_scanning_mat), P_matrix)
# Verify that the results are the same
identical(p_ij_scanning_original, p_ij_scanning_modified)  # Should return TRUE
calculate_victory_probabilities_modified1 <- function(z_mat, P) {
K <- ncol(z_mat)
N <- nrow(z_mat)
p_ij_scanning <- matrix(0, N, N)
for (i in 1:(N-1)) {
for (j in (i+1):N) {
cluster_i <- which(z_mat[i, ]==1)
cluster_j <- which(z_mat[j, ]==1)
p_ij_scanning[i, j] <- P[cbind(cluster_i, cluster_j)]
p_ij_scanning[j, i] <- 1 - p_ij_scanning[i, j]
}
}
return(p_ij_scanning)
}
# Generate example data
set.seed(123)
N <- 1000
K <- 5
z_scanning_mat <- matrix(0, nrow = N, ncol = K)
for(i in 1:N){
cluster = sample(c(1:K),size = 1)
z_scanning_mat[i,cluster] = 1
}
P_matrix <- matrix(runif(K*K), nrow = K, ncol = K)
P_matrix<-semi_symmetric(P_matrix)
diag(P_matrix)<- 0.5
# Calculate victory probabilities using Option 1 (Original)
p_ij_scanning_original <- calculate_victory_probabilities_original(z_scanning_mat, P_matrix)
# Calculate victory probabilities using Option 2 (Modified)
p_ij_scanning_modified <- calculate_victory_probabilities_modified(as.matrix(z_scanning_mat), P_matrix)
# Verify that the results are the same
identical(p_ij_scanning_original, p_ij_scanning_modified)  # Should return TRUE
# Calculate victory probabilities using Option 2 (Modified)
p_ij_scanning_modified <- calculate_victory_probabilities_modified1(as.matrix(z_scanning_mat), P_matrix)
# Verify that the results are the same
identical(p_ij_scanning_original, p_ij_scanning_modified)  # Should return TRUE
P_sparse <- as(P_matrix, "CsparseMatrix")
P_sparse
dbinom(1,2,P_sparse[1,2])
label_probability <- function(distance, sigma_z) {
prob <- dnorm(distance, mean = 0, sd = sigma_z)
return(prob)
}
label_available=1:5
k_cur=3
# Calculate distances between labels
label_distances <- abs(labels_available - k_cur)
labels_available=1:5
k_cur=3
# Calculate distances between labels
label_distances <- abs(labels_available - k_cur)
label_distances
# Calculate probabilities based on label distances and sigma.z
probabilities <- label_probability(label_distances, sigma.z)
sigma.z<-0.1
# Calculate distances between labels
label_distances <- abs(labels_available - k_cur)
# Calculate probabilities based on label distances and sigma.z
probabilities <- label_probability(label_distances, sigma.z)
probabilities
sigma.z<-0.3
# Calculate distances between labels
label_distances <- abs(labels_available - k_cur)
# Calculate probabilities based on label distances and sigma.z
probabilities <- label_probability(label_distances, sigma.z)
# Adjust probabilities based on sigma.z
probabilities <- probabilities / sum(probabilities)
probabilities
probabilities
# Sample a new label using the adjusted probabilities
k_prime <- sample(x = setdiff(labels_available, k_cur), size = 1, prob = probabilities)
# Sample a new label using the adjusted probabilities
k_prime <- sample(x = setdiff(labels_available, k_cur), size = 1, prob = setdiff(probabilities, probabilities[k_cur]))
labels_available
setdiff(labels_available, k_cur)
setdiff(probabilities, probabilities[k_cur])
# Calculate probabilities based on label distances and sigma.z
probabilities <- label_probability(label_distances, sigma.z)
# Adjust probabilities based on sigma.z
probabilities <- probabilities / sum(probabilities)
probabilities
# Sample a new label using the adjusted probabilities
k_prime <- sample(x = setdiff(labels_available, k_cur), size = 1, prob = setdiff(probabilities, probabilities[k_cur]))
setdiff(probabilities, probabilities[k_cur])
k_cur
probabilities[k_cur]
probabilities
# Sample a new label using the adjusted probabilities
k_prime <- sample(x = setdiff(labels_available, k_cur), size = 1, prob = probabilities[-k_cur])
k_prime
k_prime
k_prime
k_prime
k_prime
# Sample a new label using the adjusted probabilities
k_prime <- sample(x = setdiff(labels_available, k_cur), size = 1, prob = probabilities[-k_cur])
# Sample a new label using the adjusted probabilities
k_prime <- sample(x = setdiff(labels_available, k_cur), size = 1, prob = probabilities[-k_cur])
k_prime
# Sample a new label using the adjusted probabilities
k_prime <- sample(x = setdiff(labels_available, k_cur), size = 1, prob = probabilities[-k_cur])
sigma.z<-1
# Calculate distances between labels
label_distances <- abs(labels_available - k_cur)
# Calculate probabilities based on label distances and sigma.z
probabilities <- label_probability(label_distances, sigma.z)
# Adjust probabilities based on sigma.z
probabilities <- probabilities / sum(probabilities)
probabilities
# Sample a new label using the adjusted probabilities
k_prime <- sample(x = setdiff(labels_available, k_cur), size = 1, prob = probabilities[-k_cur])
k_prime
# Sample a new label using the adjusted probabilities
k_prime <- sample(x = setdiff(labels_available, k_cur), size = 1000, prob = probabilities[-k_cur], replace = T)
barplot(k_prime)
hist(k_prime)
barplot(table(k_prime))
labels_available=1:5
k_cur=3
sigma.z<-.3
# Calculate distances between labels
label_distances <- abs(labels_available - k_cur)
# Calculate probabilities based on label distances and sigma.z
probabilities <- label_probability(label_distances, sigma.z)
# Adjust probabilities based on sigma.z
probabilities <- probabilities / sum(probabilities)
probabilities
# Sample a new label using the adjusted probabilities
k_prime <- sample(x = setdiff(labels_available, k_cur), size = 1000, prob = probabilities[-k_cur], replace = T)
barplot(table(k_prime))
labels_available=1:5
k_cur=3
sigma.z<-2
# Calculate distances between labels
label_distances <- abs(labels_available - k_cur)
# Calculate probabilities based on label distances and sigma.z
probabilities <- label_probability(label_distances, sigma.z)
# Adjust probabilities based on sigma.z
probabilities <- probabilities / sum(probabilities)
probabilities
# Sample a new label using the adjusted probabilities
k_prime <- sample(x = setdiff(labels_available, k_cur), size = 1000, prob = probabilities[-k_cur], replace = T)
barplot(table(k_prime))
z_scanning[ii] <- k_prime
barplot(table(k_prime)/1000)
sigma.z<-2
# Calculate distances between labels
label_distances <- abs(labels_available - k_cur)
# Calculate probabilities based on label distances and sigma.z
probabilities <- label_probability(label_distances, sigma.z)
# Adjust probabilities based on sigma.z
probabilities <- probabilities / sum(probabilities)
probabilities
sigma.z<-0.2
# Calculate distances between labels
label_distances <- abs(labels_available - k_cur)
# Calculate probabilities based on label distances and sigma.z
probabilities <- label_probability(label_distances, sigma.z)
# Adjust probabilities based on sigma.z
probabilities <- probabilities / sum(probabilities)
probabilities
# Sample a new label using the adjusted probabilities
k_prime <- sample(x = setdiff(labels_available, k_cur), size = 1000, prob = probabilities[-k_cur], replace = T)
barplot(table(k_prime)/1000)
z_scanning[ii] <- k_prime
calculate_victory_probabilities_modified <- function(z_mat, P) {
# Convert z_mat to a sparse matrix if it's mostly zeros
z_mat <- sparseMatrix(i = row(z_mat), j = col(z_mat), x = z_mat)
# Calculate intermediate result and cache it
aux <- P %*% t(z_mat)
# Perform matrix multiplication using cached intermediate result
p_ij_scanning <- z_mat %*% aux
return(p_ij_scanning)
}
K <- 5
z_scanning_mat <- matrix(0, nrow = N, ncol = K)
for(i in 1:N){
cluster = sample(c(1:K),size = 1)
z_scanning_mat[i,cluster] = 1
}
P_matrix <- matrix(runif(K*K), nrow = K, ncol = K)
P_matrix<-semi_symmetric(P_matrix)
diag(P_matrix)<- 0.5
# Calculate victory probabilities using Option 1 (Original)
p_ij_scanning_original <- calculate_victory_probabilities_original(z_scanning_mat, P_matrix)
# Calculate victory probabilities using Option 2 (Modified)
p_ij_scanning_modified <- calculate_victory_probabilities_modified1(as.matrix(z_scanning_mat), P_matrix)
# Calculate victory probabilities using Option 2 (Modified)
p_ij_scanning_modified <- calculate_victory_probabilities_modified(as.matrix(z_scanning_mat), P_matrix)
calculate_victory_probabilities_modified <- function(z_mat, P) {
# Convert z_mat to a sparse matrix if it's mostly zeros
if (sum(z_mat != 0) < 0.2 * length(z_mat)) {
z_mat <- sparseMatrix(i = row(z_mat), j = col(z_mat), x = z_mat)
}
# Calculate intermediate result and cache it
aux <- P %*% t(z_mat)
# Perform matrix multiplication using cached intermediate result
p_ij_scanning <- z_mat %*% aux
return(p_ij_scanning)
}
P_sparse <- as(P_matrix, "CsparseMatrix")
dbinom(1,2,P_sparse[1,2])
# Generate example data
set.seed(123)
N <- 1000
K <- 5
z_scanning_mat <- matrix(0, nrow = N, ncol = K)
for(i in 1:N){
cluster = sample(c(1:K),size = 1)
z_scanning_mat[i,cluster] = 1
}
P_matrix <- matrix(runif(K*K), nrow = K, ncol = K)
P_matrix<-semi_symmetric(P_matrix)
diag(P_matrix)<- 0.5
# Calculate victory probabilities using Option 1 (Original)
p_ij_scanning_original <- calculate_victory_probabilities_original(z_scanning_mat, P_matrix)
# Calculate victory probabilities using Option 2 (Modified)
p_ij_scanning_modified <- calculate_victory_probabilities_modified(as.matrix(z_scanning_mat), P_matrix)
# Verify that the results are the same
identical(p_ij_scanning_original, p_ij_scanning_modified)  # Should return TRUE
# Benchmarking
benchmark_results <- microbenchmark(
original = calculate_victory_probabilities_original(z_scanning_mat, P_matrix),
modified = calculate_victory_probabilities_modified(z_scanning_mat, P_matrix),
columns = c("test", "replications", "elapsed", "relative"),
order = "relative"
)
# Print benchmark results
print(benchmark_results)
p_ij_scanning
calculate_victory_probabilities_modified <- function(z_mat, P) {
# Convert z_mat to a sparse matrix if it's mostly zeros
if (sum(z_mat != 0) < 0.2 * length(z_mat)) {
z_mat <- sparseMatrix(i = row(z_mat), j = col(z_mat), x = z_mat)
}
# Calculate intermediate result and cache it
aux <- P %*% t(z_mat)
# Perform matrix multiplication using cached intermediate result
p_ij_scanning <- z_mat %*% aux
return(p_ij_scanning)
}
# Calculate victory probabilities using Option 2 (Modified)
p_ij_scanning_modified <- calculate_victory_probabilities_modified(as.matrix(z_scanning_mat), P_matrix)
p_ij_scanning_modified
sigma.z<-0.02
# Calculate distances between labels
label_distances <- abs(labels_available - k_cur)
# Calculate probabilities based on label distances and sigma.z
probabilities <- label_probability(label_distances, sigma.z)
probabilities
# Adjust probabilities based on sigma.z
probabilities <- probabilities / sum(probabilities)
probabilities
# Sample a new label using the adjusted probabilities
k_prime <- sample(x = setdiff(labels_available, k_cur), size = 1000, prob = probabilities[-k_cur], replace = T)
k_prime
probabilities[-k_cur]
label_probability <- function(distance, sigma_z) {
prob <- dlnorm_param(distance, 0, sd = sigma_z)
return(prob)
}
labels_available=1:5
k_cur=3
sigma.z<-0.02
# Calculate distances between labels
label_distances <- abs(labels_available - k_cur)
# Calculate probabilities based on label distances and sigma.z
probabilities <- label_probability(label_distances, sigma.z)
label_probability <- function(distance, sigma_z) {
prob <- dlnorm_param(distance, 0,  sigma_z)
return(prob)
}
labels_available=1:5
k_cur=3
sigma.z<-0.02
# Calculate distances between labels
label_distances <- abs(labels_available - k_cur)
# Calculate probabilities based on label distances and sigma.z
probabilities <- label_probability(label_distances, sigma.z)
probabilities
distance
sigma.z<-0.03
# Calculate distances between labels
label_distances <- abs(labels_available - k_cur)
# Calculate probabilities based on label distances and sigma.z
probabilities <- label_probability(label_distances, sigma.z)
# Adjust probabilities based on sigma.z
probabilities <- probabilities / sum(probabilities)
label_probability <- function(distance, sigma_z) {
prob <- dnorm(distance, mean = 0, sd = sigma_z)
return(prob)
}
labels_available=1:5
k_cur=3
sigma.z<-0.03
# Calculate distances between labels
label_distances <- abs(labels_available - k_cur)
# Calculate probabilities based on label distances and sigma.z
probabilities <- label_probability(label_distances, sigma.z)
# Adjust probabilities based on sigma.z
probabilities <- probabilities / sum(probabilities)
probabilities
sigma.z<-0.1
# Calculate distances between labels
label_distances <- abs(labels_available - k_cur)
# Calculate probabilities based on label distances and sigma.z
probabilities <- label_probability(label_distances, sigma.z)
# Adjust probabilities based on sigma.z
probabilities <- probabilities / sum(probabilities)
probabilities
# Adjust probabilities based on sigma.z
probabilities <- probabilities[-k_cur] / sum(probabilities[-k_cur])
probabilities
sigma.z<-0.1
rdirichlet_multinomial(1,5,label_distances)
rdirichlet_multinomial(1,5,label_distances)
# Adjust probabilities based on sigma.z
probabilities <- probabilities[-k_cur] / sum(probabilities[-k_cur])
probabilities
rdirichlet_multinomial(1,5,label_distances)
rdirichlet_multinomial(1,5,label_distances)
rdirichlet_multinomial(1,5,label_distances)
rdirichlet_multinomial(1,5,label_distances)
barplot(table(rdirichlet_multinomial(1000,5,label_distances)))
barplot(table(rdirichlet_multinomial(1000,1,label_distances)))
rdirichlet_multinomial(1000,1,label_distances)
which(rdirichlet_multinomial(1,1,label_distances)>0)
which(rdirichlet_multinomial(10,1,label_distances)>0)
v=vector()
for(i in 1:1000){
a <- rdirichlet_multinomial(1,1,label_distances)
v = append(v, which(a>0))
}
barplot(table(v))
label_distances
# Calculate distances between labels
label_distances <- 1/abs(labels_available - k_cur)
# Calculate probabilities based on label distances and sigma.z
probabilities <- label_probability(label_distances, sigma.z)
# Adjust probabilities based on sigma.z
probabilities <- probabilities[-k_cur] / sum(probabilities[-k_cur])
probabilities
# Sample a new label using the adjusted probabilities
k_prime <- sample(x = setdiff(labels_available, k_cur), size = 1000, prob = probabilities[-k_cur], replace = T)
z_scanning[ii] <- k_prime
v=vector()
for(i in 1:1000){
a <- rdirichlet_multinomial(1,1,label_distances)
v = append(v, which(a>0))
}
barplot(table(v))
# Calculate distances between labels
label_distances <- abs(labels_available - k_cur)
# Calculate probabilities based on label distances and sigma.z
probabilities <- label_probability(label_distances, sigma.z)
label_to_use <- label_distances[-k_cur]
inverse_lab <- 1/label_to_use
inverse_lab
concentration<- 5
concentration/label_to_use
v=vector()
for(i in 1:1000){
a <- rdirichlet_multinomial(1,1,concentration/label_to_use)
v = append(v, which(a>0))
}
barplot(table(v))
concentration=8
v=vector()
for(i in 1:1000){
a <- rdirichlet_multinomial(1,1,concentration/label_to_use)
v = append(v, which(a>0))
}
barplot(table(v))
(concentration*label_to_use)/label_to_use
(concentration*label_to_use)
v=vector()
for(i in 1:1000){
a <- rdirichlet_multinomial(1,1,concentration/label_to_use)
v = append(v, which(a>0))
}
barplot(table(v))
barplot(table(v)/1000)
concentration=8
(concentration*label_to_use)
v=vector()
for(i in 1:1000){
a <- rdirichlet_multinomial(1,1,concentration/label_to_use)
v = append(v, which(a>0))
}
barplot(table(v)/1000)
concentration=9
(concentration*label_to_use)
v=vector()
for(i in 1:1000){
a <- rdirichlet_multinomial(1,1,concentration/label_to_use)
v = append(v, which(a>0))
}
barplot(table(v)/1000)
concentration=1
(concentration*label_to_use)
v=vector()
for(i in 1:1000){
a <- rdirichlet_multinomial(1,1,concentration/label_to_use)
v = append(v, which(a>0))
}
barplot(table(v)/1000)
concentration=0.5
(concentration*label_to_use)
v=vector()
for(i in 1:1000){
a <- rdirichlet_multinomial(1,1,concentration/label_to_use)
v = append(v, which(a>0))
}
barplot(table(v)/1000)
concentration/label_to_use
concentration=0.1
(concentration*label_to_use)
v=vector()
for(i in 1:1000){
a <- rdirichlet_multinomial(1,1,concentration/label_to_use)
v = append(v, which(a>0))
}
barplot(table(v)/1000)
concentration/label_to_use
library(MCMCpack)
concentration*label_to_use
rdirichlet(1, concentration*label_to_use)
concentration*label_to_use
sum(concentration*label_to_use)
rdirichlet(1, label_to_use)
rdirichlet(1, 1/label_to_use)
sum(concentration*label_to_use)
rdirichlet(1, 1/label_to_use)
rdirichlet(1, 1/label_to_use)
rdirichlet(1, 1/label_to_use)
rdirichlet(1, 1/label_to_use)
rdirichlet(1, 1/label_to_use)
rdirichlet(1, 1/label_to_use)
rdirichlet(1, 1/label_to_use)
rdirichlet(1, 1/label_to_use)
rdirichlet(10, 1/label_to_use)
