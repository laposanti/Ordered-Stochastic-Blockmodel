for(i in 1:nrow(df_support)){
if(df_support[i,]$player_1 == my_df$player_1[1]){
y_ij = y_ij + df_support[i,]$y_ij
}else if(df_support[i,]$player_1 == my_df$player_2[1]){
y_ij = y_ij + df_support[i,]$n_ij - df_support[i,]$y_ij
}
}
# if(n_victories == sum(which(df_support[,1] == edgelist[i,1] & df_support[,2] == edgelist[i,2]))){
data_clean = rbind(data_clean, data.frame(player_1 = my_df$player_1[1], player_2 = my_df$player_2[1],n_ij = n_ij, y_ij = y_ij))
# print("ok")
# }else(print("error"))
my_df = my_df[-entries,]
n = nrow(my_df)
}
data_clean= data_clean[-1,]
return(list(z_true = z_players, matches_results = data_clean, p_true = p, K_true = K))}
synth_power = simulating_tournament_powerlaw(N=N,alpha = alpha,beta_max = beta_max,min_clust = min_clust,max_clust = max_clust , M = M, n_ij_max =max_number_games, rep(1,min_clust) )
min_clust=
#simulating K from a truncated Poisson(1)
K =  min_clust
print(K)
#simulating z|K from dirichlet multinomial with gamma=1
repeat {
KtimesNmatrix = rdirichlet_multinomial(N,K,gamma_vec)
if(sum(table(colSums(KtimesNmatrix)>0)) == K){
break
}}
KtimesNmatrix
rdirichlet_multinomial(N,K,gamma_vec)
rdirichlet_multinomial <- function(N, K, alpha_vec) {
# Step 1: Draw theta from Dirichlet distribution
theta <- MCMCpack::rdirichlet(1, alpha_vec)
# Step 2: Draw n_k from Multinomial distribution for each k
n <- rmultinom(N, 1, theta)
#Step 3:
return(n)
}
print(K)
#simulating z|K from dirichlet multinomial with gamma=1
repeat {
KtimesNmatrix = rdirichlet_multinomial(N,K,gamma_vec)
if(sum(table(colSums(KtimesNmatrix)>0)) == K){
break
}}
KtimesNmatrix
sum(table(colSums(KtimesNmatrix)>0)
)
table(colSums(KtimesNmatrix)>0)
simulating_tournament_powerlaw<- function(N,alpha, beta_max, min_clust,max_clust,M, n_ij_max, gamma_vec){
#simulating K from a truncated Poisson(1)
K =  min_clust
print(K)
#simulating z|K from dirichlet multinomial with gamma=1
repeat {
KtimesNmatrix = rdirichlet_multinomial(N,K,gamma_vec)
if(sum(table(colSums(KtimesNmatrix)>0)) == N){
break
}}
z = matrix(0,N,1)
for(i in 1:ncol(KtimesNmatrix)){
z[i]= which(KtimesNmatrix[,i] >0)}
print(z)
# simulating the matrix p according to the SST property
p = simulating_POMM_powerlaw(K,alpha,beta_max)$matrix
#creating the first dataframe
z_players <- data.frame(id = 1:N, z = z)
#the probability of playing is inversely related to the cluster size
aux2=  data.frame(z = c(1:K), p = sort(z, decreasing = T))
#probability of two players being extracted
aux2= left_join( z_players,aux2,by="z", multiple='all')
aux2$p = aux2$p/sum( aux2$p)
df = data.frame(player_1=NA, player_2=NA, n_ij=NA, y_ij=NA, p_ij=NA)
i=0
while(i<M){
pl_1_i <- sample(z_players$id, size=1, prob = aux2$p)
pl_2_i <-sample(setdiff(z_players$id,pl_1_i),
size=1, prob = aux2$p[setdiff(z_players$id,pl_1_i)])
matches_i = data.frame(pl_1_i, pl_2_i)
matches_i$z_1 <- z_players[which(z_players$id == pl_1_i),]$z
matches_i$z_2 <- z_players[which(z_players$id == pl_2_i),]$z
matches_i$n_ij = sample_truncated_poisson(1,p[cbind(matches_i$z_1,matches_i$z_2)]*n_ij_max ,a = 1,b = n_ij_max)
matches_i$y_ij =  rbinom(n = 1, size = matches_i$n_ij,prob =  p[cbind(matches_i$z_1,matches_i$z_2)])
df = rbind(df, data.frame(player_1 = matches_i$pl_1_i,
player_2= matches_i$pl_2_i,
n_ij = matches_i$n_ij,
y_ij = matches_i$y_ij,
p_ij = p[cbind(matches_i$z_1,matches_i$z_2)]))
i=i+1
}
df = df[-1,]
my_df = df
rownames(my_df) = 1:nrow(my_df)
head(my_df)
data_clean = data.frame(player_1=NA, player_2=NA, n_ij=NA, y_ij=NA)
n = nrow(my_df)
while(n > 0){
entries = c(which(my_df$player_1 == my_df$player_1[1] & my_df$player_2 == my_df$player_2[1]), which(my_df$player_1 == my_df$player_2[1] & my_df$player_2 == my_df$player_1[1]))
df_support = my_df[entries,]
n_ij = sum(df_support$n_ij)
y_ij = 0
for(i in 1:nrow(df_support)){
if(df_support[i,]$player_1 == my_df$player_1[1]){
y_ij = y_ij + df_support[i,]$y_ij
}else if(df_support[i,]$player_1 == my_df$player_2[1]){
y_ij = y_ij + df_support[i,]$n_ij - df_support[i,]$y_ij
}
}
# if(n_victories == sum(which(df_support[,1] == edgelist[i,1] & df_support[,2] == edgelist[i,2]))){
data_clean = rbind(data_clean, data.frame(player_1 = my_df$player_1[1], player_2 = my_df$player_2[1],n_ij = n_ij, y_ij = y_ij))
# print("ok")
# }else(print("error"))
my_df = my_df[-entries,]
n = nrow(my_df)
}
data_clean= data_clean[-1,]
return(list(z_true = z_players, matches_results = data_clean, p_true = p, K_true = K))}
synth_power = simulating_tournament_powerlaw(N=N,alpha = alpha,beta_max = beta_max,min_clust = min_clust,max_clust = max_clust , M = M, n_ij_max =max_number_games, rep(1,min_clust) )
# simulating the matrix p according to the SST property
p = simulating_POMM_powerlaw(K,alpha,beta_max)$matrix
#creating the first dataframe
z_players <- data.frame(id = 1:N, z = z)
#the probability of playing is inversely related to the cluster size
aux2=  data.frame(z = c(1:K), p = sort(z, decreasing = T))
table(z)/N
simulating_tournament_powerlaw<- function(N,alpha, beta_max, min_clust,max_clust,M, n_ij_max, gamma_vec){
#simulating K from a truncated Poisson(1)
K =  min_clust
print(K)
#simulating z|K from dirichlet multinomial with gamma=1
repeat {
KtimesNmatrix = rdirichlet_multinomial(N,K,gamma_vec)
if(sum(table(colSums(KtimesNmatrix)>0)) == N){
break
}}
z = matrix(0,N,1)
for(i in 1:ncol(KtimesNmatrix)){
z[i]= which(KtimesNmatrix[,i] >0)}
print(z)
# simulating the matrix p according to the SST property
p = simulating_POMM_powerlaw(K,alpha,beta_max)$matrix
#creating the first dataframe
z_players <- data.frame(id = 1:N, z = z)
#the probability of playing is inversely related to the cluster size
aux2=  data.frame(z = c(1:K), p = sort(table(z)/N, decreasing = T))
#probability of two players being extracted
aux2= left_join( z_players,aux2,by="z", multiple='all')
aux2$p = aux2$p/sum( aux2$p)
df = data.frame(player_1=NA, player_2=NA, n_ij=NA, y_ij=NA, p_ij=NA)
i=0
while(i<M){
pl_1_i <- sample(z_players$id, size=1, prob = aux2$p)
pl_2_i <-sample(setdiff(z_players$id,pl_1_i),
size=1, prob = aux2$p[setdiff(z_players$id,pl_1_i)])
matches_i = data.frame(pl_1_i, pl_2_i)
matches_i$z_1 <- z_players[which(z_players$id == pl_1_i),]$z
matches_i$z_2 <- z_players[which(z_players$id == pl_2_i),]$z
matches_i$n_ij = sample_truncated_poisson(1,p[cbind(matches_i$z_1,matches_i$z_2)]*n_ij_max ,a = 1,b = n_ij_max)
matches_i$y_ij =  rbinom(n = 1, size = matches_i$n_ij,prob =  p[cbind(matches_i$z_1,matches_i$z_2)])
df = rbind(df, data.frame(player_1 = matches_i$pl_1_i,
player_2= matches_i$pl_2_i,
n_ij = matches_i$n_ij,
y_ij = matches_i$y_ij,
p_ij = p[cbind(matches_i$z_1,matches_i$z_2)]))
i=i+1
}
df = df[-1,]
my_df = df
rownames(my_df) = 1:nrow(my_df)
head(my_df)
data_clean = data.frame(player_1=NA, player_2=NA, n_ij=NA, y_ij=NA)
n = nrow(my_df)
while(n > 0){
entries = c(which(my_df$player_1 == my_df$player_1[1] & my_df$player_2 == my_df$player_2[1]), which(my_df$player_1 == my_df$player_2[1] & my_df$player_2 == my_df$player_1[1]))
df_support = my_df[entries,]
n_ij = sum(df_support$n_ij)
y_ij = 0
for(i in 1:nrow(df_support)){
if(df_support[i,]$player_1 == my_df$player_1[1]){
y_ij = y_ij + df_support[i,]$y_ij
}else if(df_support[i,]$player_1 == my_df$player_2[1]){
y_ij = y_ij + df_support[i,]$n_ij - df_support[i,]$y_ij
}
}
# if(n_victories == sum(which(df_support[,1] == edgelist[i,1] & df_support[,2] == edgelist[i,2]))){
data_clean = rbind(data_clean, data.frame(player_1 = my_df$player_1[1], player_2 = my_df$player_2[1],n_ij = n_ij, y_ij = y_ij))
# print("ok")
# }else(print("error"))
my_df = my_df[-entries,]
n = nrow(my_df)
}
data_clean= data_clean[-1,]
return(list(z_true = z_players, matches_results = data_clean, p_true = p, K_true = K))}
synth_power = simulating_tournament_powerlaw(N=N,alpha = alpha,beta_max = beta_max,min_clust = min_clust,max_clust = max_clust , M = M, n_ij_max =max_number_games, rep(1,min_clust) )
min_clust=
#simulating K from a truncated Poisson(1)
K =  min_clust
print(K)
#simulating z|K from dirichlet multinomial with gamma=1
repeat {
KtimesNmatrix = rdirichlet_multinomial(N,K,gamma_vec)
if(sum(table(colSums(KtimesNmatrix)>0)) == N){
break
}}
z = matrix(0,N,1)
for(i in 1:ncol(KtimesNmatrix)){
z[i]= which(KtimesNmatrix[,i] >0)}
print(z)
# simulating the matrix p according to the SST property
p = simulating_POMM_powerlaw(K,alpha,beta_max)$matrix
#creating the first dataframe
z_players <- data.frame(id = 1:N, z = z)
#the probability of playing is inversely related to the cluster size
aux2=  data.frame(z = c(1:K), p = sort(table(z)/N, decreasing = T))
#probability of two players being extracted
aux2= left_join( z_players,aux2,by="z", multiple='all')
aux2$p = aux2$p/sum( aux2$p)
aux2
#creating the first dataframe
z_players <- data.frame(id = 1:N, z = z)
#the probability of playing is inversely related to the cluster size
aux2=  data.frame(z = c(1:K), p = sort(table(z)/N, decreasing = T))
aux2
#the probability of playing is inversely related to the cluster size
aux2=  data.frame(z = c(1:K), p = sort(as.vector(table(z)/N), decreasing = T))
aux2
#probability of two players being extracted
aux2= left_join( z_players,aux2,by="z", multiple='all')
aux2
aux2$p = aux2$p/sum( aux2$p)
#the probability of playing is inversely related to the cluster size
aux2=  data.frame(z = c(1:K), p = sort(table(z)/N, decreasing = T))
#probability of two players being extracted
aux2= left_join( z_players,aux2,by="z", multiple='all')
aux2$p = aux2$p/sum( aux2$p)
aux2$p = aux2$p/sum( aux2$p)
#the probability of playing is inversely related to the cluster size
aux2=  data.frame(z = c(1:K), p = sort(as.vector(table(z)/N), decreasing = T))
#probability of two players being extracted
aux2= left_join( z_players,aux2,by="z", multiple='all')
aux2$p = aux2$p/sum( aux2$p)
aux2$p
#creating the first dataframe
z_players <- data.frame(id = 1:N, z = z)
#the probability of playing is inversely related to the cluster size
aux2=  data.frame(z = c(1:K), p = sort(as.vector(table(z)/N), decreasing = T))
#probability of two players being extracted
aux2= left_join( z_players,aux2,by="z", multiple='all')
aux2$p = aux2$p/sum( aux2$p)
aux2$p
#creating the first dataframe
z_players <- data.frame(id = 1:N, z = z)
#the probability of playing is inversely related to the cluster size
aux2=  data.frame(z = c(1:K), p = sort(as.vector(table(z)/N), decreasing = T))
aux2
# simulating the matrix p according to the SST property
p = simulating_POMM_powerlaw(K,alpha,beta_max)$matrix
#creating the first dataframe
z_players <- data.frame(id = 1:N, z = z)
#the probability of playing is inversely related to the cluster size
aux2=  data.frame(z = c(1:K), p = sort(as.vector(table(z)/N), decreasing = T))
aux2
min_clust=
#simulating K from a truncated Poisson(1)
K =  min_clust
print(K)
#simulating z|K from dirichlet multinomial with gamma=1
repeat {
KtimesNmatrix = rdirichlet_multinomial(N,K,gamma_vec)
if(sum(table(colSums(KtimesNmatrix)>0)) == N){
break
}}
z = matrix(0,N,1)
for(i in 1:ncol(KtimesNmatrix)){
z[i]= which(KtimesNmatrix[,i] >0)}
print(z)
rdirichlet_multinomial(N,K,gamma_vec)
gamma_vec
min_clust=
gamma_vec=rep(1,K)
#simulating K from a truncated Poisson(1)
K =  min_clust
print(K)
#simulating z|K from dirichlet multinomial with gamma=1
repeat {
KtimesNmatrix = rdirichlet_multinomial(N,K,gamma_vec)
if(sum(table(colSums(KtimesNmatrix)>0)) == N){
break
}}
z = matrix(0,N,1)
for(i in 1:ncol(KtimesNmatrix)){
z[i]= which(KtimesNmatrix[,i] >0)}
print(z)
# simulating the matrix p according to the SST property
p = simulating_POMM_powerlaw(K,alpha,beta_max)$matrix
#creating the first dataframe
z_players <- data.frame(id = 1:N, z = z)
#the probability of playing is inversely related to the cluster size
aux2=  data.frame(z = c(1:K), p = sort(as.vector(table(z)/N), decreasing = T))
aux2
sort(as.vector(table(z)/N)
cluster_proportions = sort(as.vector(table(z)/N), decreasing = T)
cluster_proportions
cluster_proportions = sort(as.vector(table(z)/N), decreasing = T)
cluster_proportions
#the probability of playing is inversely related to the cluster size
aux2=  data.frame(z = c(1:K), p = cluster_proportions, decreasing = T))
#the probability of playing is inversely related to the cluster size
aux2=  data.frame(z = c(1:K), p = cluster_proportions)
labels_available = c(1:K)
c(1:K)
#simulating K from a truncated Poisson(1)
K =  min_clust
#simulating K from a truncated Poisson(1)
K =  min_clust
labels_available = c(1:K)
labels_available = seq(1,K,1)
#simulating K from a truncated Poisson(1)
K =  min_clust
K
min_clust
#simulating K from a truncated Poisson(1)
K = 3
rep(1,min_clust)
min_clust
min_clust=3
rep(1,min_clust)
gamma_vec=rep(1,K)
#simulating K from a truncated Poisson(1)
K = 3
print(K)
#simulating z|K from dirichlet multinomial with gamma=1
repeat {
KtimesNmatrix = rdirichlet_multinomial(N,K,gamma_vec)
if(sum(table(colSums(KtimesNmatrix)>0)) == N){
break
}}
z = matrix(0,N,1)
for(i in 1:ncol(KtimesNmatrix)){
z[i]= which(KtimesNmatrix[,i] >0)}
print(z)
# simulating the matrix p according to the SST property
p = simulating_POMM_powerlaw(K,alpha,beta_max)$matrix
#creating the first dataframe
z_players <- data.frame(id = 1:N, z = z)
cluster_proportions = sort(as.vector(table(z)/N), decreasing = T)
labels_available = seq(1,K,1)
#the probability of playing is inversely related to the cluster size
aux2=  data.frame(z = c(1:K), p = cluster_proportions)
#the probability of playing is inversely related to the cluster size
aux2=  data.frame(z = labels_available, p = cluster_proportions)
#probability of two players being extracted
aux2= left_join( z_players,aux2,by="z", multiple='all')
aux2$p = aux2$p/sum( aux2$p)
aux2$p
simulating_tournament_powerlaw<- function(N,alpha, beta_max, min_clust,max_clust,M, n_ij_max, gamma_vec){
#simulating K from a truncated Poisson(1)
K =  min_clust
print(K)
#simulating z|K from dirichlet multinomial with gamma=1
repeat {
KtimesNmatrix = rdirichlet_multinomial(N,K,gamma_vec)
if(sum(table(colSums(KtimesNmatrix)>0)) == N){
break
}}
z = matrix(0,N,1)
for(i in 1:ncol(KtimesNmatrix)){
z[i]= which(KtimesNmatrix[,i] >0)}
print(z)
# simulating the matrix p according to the SST property
p = simulating_POMM_powerlaw(K,alpha,beta_max)$matrix
#creating the first dataframe
z_players <- data.frame(id = 1:N, z = z)
cluster_proportions = sort(as.vector(table(z)/N), decreasing = T)
labels_available = seq(1,K,1)
#the probability of playing is inversely related to the cluster size
aux2=  data.frame(z = labels_available, p = cluster_proportions)
#probability of two players being extracted
aux2= left_join( z_players,aux2,by="z", multiple='all')
aux2$p = aux2$p/sum( aux2$p)
df = data.frame(player_1=NA, player_2=NA, n_ij=NA, y_ij=NA, p_ij=NA)
i=0
while(i<M){
pl_1_i <- sample(z_players$id, size=1, prob = aux2$p)
pl_2_i <-sample(setdiff(z_players$id,pl_1_i),
size=1, prob = aux2$p[setdiff(z_players$id,pl_1_i)])
matches_i = data.frame(pl_1_i, pl_2_i)
matches_i$z_1 <- z_players[which(z_players$id == pl_1_i),]$z
matches_i$z_2 <- z_players[which(z_players$id == pl_2_i),]$z
matches_i$n_ij = sample_truncated_poisson(1,p[cbind(matches_i$z_1,matches_i$z_2)]*n_ij_max ,a = 1,b = n_ij_max)
matches_i$y_ij =  rbinom(n = 1, size = matches_i$n_ij,prob =  p[cbind(matches_i$z_1,matches_i$z_2)])
df = rbind(df, data.frame(player_1 = matches_i$pl_1_i,
player_2= matches_i$pl_2_i,
n_ij = matches_i$n_ij,
y_ij = matches_i$y_ij,
p_ij = p[cbind(matches_i$z_1,matches_i$z_2)]))
i=i+1
}
df = df[-1,]
my_df = df
rownames(my_df) = 1:nrow(my_df)
head(my_df)
data_clean = data.frame(player_1=NA, player_2=NA, n_ij=NA, y_ij=NA)
n = nrow(my_df)
while(n > 0){
entries = c(which(my_df$player_1 == my_df$player_1[1] & my_df$player_2 == my_df$player_2[1]), which(my_df$player_1 == my_df$player_2[1] & my_df$player_2 == my_df$player_1[1]))
df_support = my_df[entries,]
n_ij = sum(df_support$n_ij)
y_ij = 0
for(i in 1:nrow(df_support)){
if(df_support[i,]$player_1 == my_df$player_1[1]){
y_ij = y_ij + df_support[i,]$y_ij
}else if(df_support[i,]$player_1 == my_df$player_2[1]){
y_ij = y_ij + df_support[i,]$n_ij - df_support[i,]$y_ij
}
}
# if(n_victories == sum(which(df_support[,1] == edgelist[i,1] & df_support[,2] == edgelist[i,2]))){
data_clean = rbind(data_clean, data.frame(player_1 = my_df$player_1[1], player_2 = my_df$player_2[1],n_ij = n_ij, y_ij = y_ij))
# print("ok")
# }else(print("error"))
my_df = my_df[-entries,]
n = nrow(my_df)
}
data_clean= data_clean[-1,]
return(list(z_true = z_players, matches_results = data_clean, p_true = p, K_true = K))}
synth_power = simulating_tournament_powerlaw(N=N,alpha = alpha,beta_max = beta_max,min_clust = min_clust,max_clust = max_clust , M = M, n_ij_max =max_number_games, gamma_vec = rep(1,min_clust) )
KtimesNmatrix
rowSums(KtimesNmatrix)>0)
rowSums(KtimesNmatrix)
table(rowSums(KtimesNmatrix)>0)
sum(table(rowSums(KtimesNmatrix)>0))
simulating_tournament_powerlaw<- function(N,alpha, beta_max, min_clust,max_clust,M, n_ij_max, gamma_vec){
#simulating K from a truncated Poisson(1)
K =  min_clust
#simulating z|K from dirichlet multinomial with gamma=1
repeat {
KtimesNmatrix = rdirichlet_multinomial(N,K,gamma_vec)
if(sum(table(rowSums(KtimesNmatrix)>0)) == K){
break
}}
z = matrix(0,N,1)
for(i in 1:ncol(KtimesNmatrix)){
z[i]= which(KtimesNmatrix[,i] >0)}
# simulating the matrix p according to the SST property
p = simulating_POMM_powerlaw(K,alpha,beta_max)$matrix
#creating the first dataframe
z_players <- data.frame(id = 1:N, z = z)
cluster_proportions = sort(as.vector(table(z)/N), decreasing = T)
labels_available = seq(1,K,1)
#the probability of playing is inversely related to the cluster size
aux2=  data.frame(z = labels_available, p = cluster_proportions)
#probability of two players being extracted
aux2= left_join( z_players,aux2,by="z", multiple='all')
aux2$p = aux2$p/sum( aux2$p)
df = data.frame(player_1=NA, player_2=NA, n_ij=NA, y_ij=NA, p_ij=NA)
i=0
while(i<M){
pl_1_i <- sample(z_players$id, size=1, prob = aux2$p)
pl_2_i <-sample(setdiff(z_players$id,pl_1_i),
size=1, prob = aux2$p[setdiff(z_players$id,pl_1_i)])
matches_i = data.frame(pl_1_i, pl_2_i)
matches_i$z_1 <- z_players[which(z_players$id == pl_1_i),]$z
matches_i$z_2 <- z_players[which(z_players$id == pl_2_i),]$z
matches_i$n_ij = sample_truncated_poisson(1,p[cbind(matches_i$z_1,matches_i$z_2)]*n_ij_max ,a = 1,b = n_ij_max)
matches_i$y_ij =  rbinom(n = 1, size = matches_i$n_ij,prob =  p[cbind(matches_i$z_1,matches_i$z_2)])
df = rbind(df, data.frame(player_1 = matches_i$pl_1_i,
player_2= matches_i$pl_2_i,
n_ij = matches_i$n_ij,
y_ij = matches_i$y_ij,
p_ij = p[cbind(matches_i$z_1,matches_i$z_2)]))
i=i+1
}
df = df[-1,]
my_df = df
rownames(my_df) = 1:nrow(my_df)
head(my_df)
data_clean = data.frame(player_1=NA, player_2=NA, n_ij=NA, y_ij=NA)
n = nrow(my_df)
while(n > 0){
entries = c(which(my_df$player_1 == my_df$player_1[1] & my_df$player_2 == my_df$player_2[1]), which(my_df$player_1 == my_df$player_2[1] & my_df$player_2 == my_df$player_1[1]))
df_support = my_df[entries,]
n_ij = sum(df_support$n_ij)
y_ij = 0
for(i in 1:nrow(df_support)){
if(df_support[i,]$player_1 == my_df$player_1[1]){
y_ij = y_ij + df_support[i,]$y_ij
}else if(df_support[i,]$player_1 == my_df$player_2[1]){
y_ij = y_ij + df_support[i,]$n_ij - df_support[i,]$y_ij
}
}
# if(n_victories == sum(which(df_support[,1] == edgelist[i,1] & df_support[,2] == edgelist[i,2]))){
data_clean = rbind(data_clean, data.frame(player_1 = my_df$player_1[1], player_2 = my_df$player_2[1],n_ij = n_ij, y_ij = y_ij))
# print("ok")
# }else(print("error"))
my_df = my_df[-entries,]
n = nrow(my_df)
}
data_clean= data_clean[-1,]
return(list(z_true = z_players, matches_results = data_clean, p_true = p, K_true = K))}
rowSums(KtimesNmatrix)>0)
rowSums(KtimesNmatrix)>0
simulating_tournament_powerlaw<- function(N,alpha, beta_max, min_clust,max_clust,M, n_ij_max, gamma_vec){
#simulating K from a truncated Poisson(1)
K =  min_clust
#simulating z|K from dirichlet multinomial with gamma=1
repeat {
KtimesNmatrix = rdirichlet_multinomial(N,K,gamma_vec)
if(sum(table(rowSums(KtimesNmatrix)>0)) == K){
break
}}
print(rowSums(KtimesNmatrix)>0))
print(rowSums(KtimesNmatrix)>0)
sum(rowSums(KtimesNmatrix)>0)
