ts.plot(posterior_prop[-c(1:100)])
MAP = z_container[, which(posterior_prop == max(posterior_prop))[1]]
acceptance_rate= acc.count_z/(N*N_iter)*100
print(acceptance_rate)
#estimates
similarity_matrix = pr_cc(z_container[,-c(1:N_iter*0.50)])
point_est = minVI(similarity_matrix)$cl
adj.rand.index(MAP, z_true)
adj.rand.index(point_est, z_true)
similarity_plot(y_ij_matrix,synth$z_true,synth$z_true)
similarity_plot(similarity_matrix,synth$z_true,synth$z_true)
adj.rand.index(point_est, z_true)
adj.rand.index(MAP, z_true)
barplot(rowSums(y_ij_matrix)/rowSums(n_ij_matrix))
# Load required libraries
library(foreach)
library(doParallel)
# Set up simulation parameters
K_values <- c(3,5,9)  # Range of K values to explore
overlap_values <- c(0.2,0.4,0.6)    # Range of overlap values to explore
alpha_values <- c(.5,1,1.5) # Range of alpha values to explore
switch_values <- c(1,0) # Range of models to explore: 1= POMM, 0 =Simple
# Set other fixed parameters
N <- 100
M <- 4000 #number of games in the tournament
N_iter<-40000 #number of iterations
targ_rate <-0.22
beta_max <- 0.85
diag0.5 <- T
# Set up parallel computing
cores <- 5
cl <- makeCluster(cores)
registerDoParallel(cl)
# Iterate over parameter combinations using foreach
combinations = expand_grid(K_values,alpha_values,overlap_values)
setwd("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/POMM_flex/MCMC/results")
test_grid = expand_grid(K_values, switch_values)
samples <- 5
foreach(combn = 1:nrow(test_grid)) %dopar% {
library(truncnorm)
library(dplyr)
library(EnvStats)
overlap <- 0.2
alpha <- 0.5
K <- test_grid$K_values[combn]
gamma_vec=vector()
for(i in 1:K){
gamma_vec = append(gamma_vec, i/(K**2))
}
seed = 79141
set.seed(seed)
switch_on_off <- test_grid$switch_values[combn] #selects from which model to generate
model <- ifelse(switch_on_off, 'POMM', 'Simple')
synth <- simulating_tournament_new_overlap_norm(N = N, alpha = alpha, overlap = overlap,
beta_max = beta_max,
K = K, M = M,
gamma_vec = gamma_vec,
n_ij_max = 6, model = model, diag0.5 = TRUE
)
Nij_matrix <- synth$n_ij_true
Yij_matrix <- synth$y_ij_true
z_true <- synth$z_true
p_true <- synth$P_matrix
#initialising the relevant quantities
overlap0 <- runif(1,0.2,.9)
alpha0 <- runif(1,0.2,1.5)
z0 <- sample(x = c(1:K),size = N, replace = T)
init = list(overlap0 = overlap0, alpha0 = alpha0, z0 = z0)
#------
#POMMM
#------
# Call adaptive_MCMC_POMM function and store results
samples <- adaptive_MCMC_POMM(Yij_matrix, Nij_matrix, init, z_true, overlap, alpha, p_true, N, K, N_iter, targ_rate, beta_max, gamma_vec, diag0.5,seed)
filename <- paste0("True_Model",model,"Est_model_POMM","K", K, "_overlap", overlap, "_alpha", alpha, "_seed", seed,".RDS")
saveRDS(samples, file = filename) #saving results
#------
#Simple
#------
samples_simple <- adaptive_MCMC_simple_model(Yij_matrix, Nij_matrix,init,z_true,p_true, N,K, N_iter, gamma_vec, diag0.5,seed)
filename_simple <- paste0("True_Model",model,"Est_model_Simple","K", K, "_overlap", overlap, "_alpha", alpha,"_seed", seed, ".RDS")
saveRDS(samples_simple, file = filename_simple) #saving results
}
stopCluster(cl)
N=100
M= 4000
K=9
alpha=0.5
beta_max= .85
gamma_vec = vector()
for(i in 1:K){
gamma_vec = append(gamma_vec, i/(K**2))
}
diag0.5<-T
synth = simulating_tournament_new_overlap_norm(N = N, alpha = alpha,
beta_max = beta_max,
K=K, M = M,
gamma_vec = gamma_vec,
n_ij_max = 6,model = 'Simple',diag0.5 = diag0.5, overlap = overlap
)
n_ij_matrix=synth$n_ij_true
y_ij_matrix=synth$y_ij_true
p_ij_true=synth$p_ij_true
z_true=synth$z_true
P_true= synth$P_matrix
similarity_plot(y_ij_matrix, z_true,z_true)
barplot(rowSums(y_ij_matrix)/rowSums(n_ij_matrix))
barplot(rowSums(y_ij_matrix))
barplot(rowSums(y_ij_matrix)
barplot(rowSums(y_ij_matrix))
barplot(rowSums(y_ij_matrix))
barplot(rowSums(n_ij_matrix))
library(foreach)
library(doParallel)
# Set up simulation parameters
K_values <- c(3,5,9)  # Range of K values to explore
overlap_values <- c(0.2,0.4,0.6)    # Range of overlap values to explore
alpha_values <- c(.5,1,1.5) # Range of alpha values to explore
switch_values <- c(1,0) # Range of models to explore: 1= POMM, 0 =Simple
# Set other fixed parameters
N <- 100
M <- 4000 #number of games in the tournament
N_iter<-40000 #number of iterations
targ_rate <-0.22
beta_max <- 0.85
diag0.5 <- T
# Set up parallel computing
cores <- 5
cl <- makeCluster(cores)
registerDoParallel(cl)
# Iterate over parameter combinations using foreach
combinations = expand_grid(K_values,alpha_values,overlap_values)
setwd("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/POMM_flex/MCMC/results")
test_grid = expand_grid(K_values, switch_values)
samples <- 5
foreach(combn = 1:nrow(test_grid)) %dopar% {
library(truncnorm)
library(dplyr)
library(EnvStats)
overlap <- 0.2
alpha <- 0.5
K <- test_grid$K_values[combn]
gamma_vec=vector()
for(i in 1:K){
gamma_vec = append(gamma_vec, i/(K**2))
}
seed = 79141
set.seed(seed)
switch_on_off <- test_grid$switch_values[combn] #selects from which model to generate
model <- ifelse(switch_on_off, 'POMM', 'Simple')
synth <- simulating_tournament_new_overlap_norm(N = N, alpha = alpha, overlap = overlap,
beta_max = beta_max,
K = K, M = M,
gamma_vec = gamma_vec,
n_ij_max = 6, model = model, diag0.5 = TRUE
)
Nij_matrix <- synth$n_ij_true
Yij_matrix <- synth$y_ij_true
z_true <- synth$z_true
p_true <- synth$P_matrix
#initialising the relevant quantities
overlap0 <- runif(1,0.2,.9)
alpha0 <- runif(1,0.2,1.5)
z0 <- sample(x = c(1:K),size = N, replace = T)
init = list(overlap0 = overlap0, alpha0 = alpha0, z0 = z0)
#------
#POMMM
#------
# Call adaptive_MCMC_POMM function and store results
samples <- adaptive_MCMC_POMM(Yij_matrix, Nij_matrix, init, z_true, overlap, alpha, p_true, N, K, N_iter, targ_rate, beta_max, gamma_vec, diag0.5,seed)
filename <- paste0("True_Model",model,"Est_model_POMM","K", K, "_overlap", overlap, "_alpha", alpha, "_seed", seed,".RDS")
saveRDS(samples, file = filename) #saving results
#------
#Simple
#------
samples_simple <- adaptive_MCMC_simple_model(Yij_matrix, Nij_matrix,init,z_true,p_true, N,K, N_iter, gamma_vec, diag0.5,seed)
filename_simple <- paste0("True_Model",model,"Est_model_Simple","K", K, "_overlap", overlap, "_alpha", alpha,"_seed", seed, ".RDS")
saveRDS(samples_simple, file = filename_simple) #saving results
}
stopCluster(cl)
POMMPOMM_name <- list.files(pattern = "True_ModelPOMMEst_model_POMM")
POMMSimple_name <- list.files(pattern = "True_ModelPOMMEst_model_Simple")
SimpleSimple_name<- list.files(pattern = "True_ModelSimpleEst_model_Simple")
SimplePOMM_name<- list.files(pattern = "True_ModelSimpleEst_model_POMM")
POMMPOMM = list()
#uploading the data
obj_POMM<- readRDS(SimplePOMM_name[1])
obj_Simple <- readRDS(SimpleSimple_name[1])
A_container_POMM <- obj_POMM$A_container #likelihood across iterations
A_container_Simple <- obj_Simple$A_container
z_container_POMM <- obj_POMM$z_container #similarity matrix
z_container_Simple <- obj_Simple$z_container
z_truePOMM <- obj_POMM$z_true #true underlying value
z_trueSimple<- obj_Simple$z_true
identical(z_truePOMM,z_trueSimple) #check: they should be identical
similarity_plot(obj_POMM$Yij_matrix, z_truePOMM, z_truePOMM)
obj_Simple$p_true
#Data used to generate the data
K <- nrow(obj_Simple$p_true)
#uploading the data
obj_POMM<- readRDS(SimplePOMM_name[2])
obj_Simple <- readRDS(SimpleSimple_name[1])
#Data used to generate the data
K <- nrow(obj_Simple$p_true)
A_container_POMM <- obj_POMM$A_container #likelihood across iterations
A_container_Simple <- obj_Simple$A_container
z_container_POMM <- obj_POMM$z_container #similarity matrix
z_container_Simple <- obj_Simple$z_container
z_truePOMM <- obj_POMM$z_true #true underlying value
z_trueSimple<- obj_Simple$z_true
identical(z_truePOMM,z_trueSimple) #check: they should be identical
similarity_plot(obj_POMM$Yij_matrix, z_truePOMM, z_truePOMM)
#uploading the data
obj_POMM<- readRDS(SimplePOMM_name[3])
obj_Simple <- readRDS(SimpleSimple_name[1])
#Data used to generate the data
K <- nrow(obj_Simple$p_true)
A_container_POMM <- obj_POMM$A_container #likelihood across iterations
A_container_Simple <- obj_Simple$A_container
z_container_POMM <- obj_POMM$z_container #similarity matrix
z_container_Simple <- obj_Simple$z_container
z_truePOMM <- obj_POMM$z_true #true underlying value
z_trueSimple<- obj_Simple$z_true
identical(z_truePOMM,z_trueSimple) #check: they should be identical
similarity_plot(obj_POMM$Yij_matrix, z_truePOMM, z_truePOMM)
#uploading the data
obj_POMM<- readRDS(POMMPOMM_name[1])
obj_Simple <- readRDS(SimpleSimple_name[1])
#Data used to generate the data
K <- nrow(obj_Simple$p_true)
A_container_POMM <- obj_POMM$A_container #likelihood across iterations
A_container_Simple <- obj_Simple$A_container
z_container_POMM <- obj_POMM$z_container #similarity matrix
z_container_Simple <- obj_Simple$z_container
z_truePOMM <- obj_POMM$z_true #true underlying value
z_trueSimple<- obj_Simple$z_true
identical(z_truePOMM,z_trueSimple) #check: they should be identical
similarity_plot(obj_POMM$Yij_matrix, z_truePOMM, z_truePOMM)
#uploading the data
obj_POMM<- readRDS(POMMPOMM_name[2])
obj_Simple <- readRDS(SimpleSimple_name[1])
#Data used to generate the data
K <- nrow(obj_Simple$p_true)
A_container_POMM <- obj_POMM$A_container #likelihood across iterations
A_container_Simple <- obj_Simple$A_container
z_container_POMM <- obj_POMM$z_container #similarity matrix
z_container_Simple <- obj_Simple$z_container
z_truePOMM <- obj_POMM$z_true #true underlying value
z_trueSimple<- obj_Simple$z_true
identical(z_truePOMM,z_trueSimple) #check: they should be identical
similarity_plot(obj_POMM$Yij_matrix, z_truePOMM, z_truePOMM)
#extracting similarity matrix
similarity_matrixPOMMM = pr_cc(z_container_POMM[,-c(1:10000)])
#uploading the data
obj_POMM<- readRDS(POMMPOMM_name[3])
obj_Simple <- readRDS(SimpleSimple_name[1])
#Data used to generate the data
K <- nrow(obj_Simple$p_true)
A_container_POMM <- obj_POMM$A_container #likelihood across iterations
A_container_Simple <- obj_Simple$A_container
z_container_POMM <- obj_POMM$z_container #similarity matrix
z_container_Simple <- obj_Simple$z_container
z_truePOMM <- obj_POMM$z_true #true underlying value
z_trueSimple<- obj_Simple$z_true
identical(z_truePOMM,z_trueSimple) #check: they should be identical
similarity_plot(obj_POMM$Yij_matrix, z_truePOMM, z_truePOMM)
#uploading the data
obj_POMM<- readRDS(POMMPOMM_name[1])
obj_Simple <- readRDS(SimpleSimple_name[1])
#uploading the data
obj_POMM<- readRDS(SimplePOMM_name[1])
obj_Simple <- readRDS(SimpleSimple_name[1])
#Data used to generate the data
K <- nrow(obj_Simple$p_true)
A_container_POMM <- obj_POMM$A_container #likelihood across iterations
A_container_Simple <- obj_Simple$A_container
z_container_POMM <- obj_POMM$z_container #similarity matrix
z_container_Simple <- obj_Simple$z_container
z_truePOMM <- obj_POMM$z_true #true underlying value
z_trueSimple<- obj_Simple$z_true
identical(z_truePOMM,z_trueSimple) #check: they should be identical
#extracting similarity matrix
similarity_matrixPOMMM = pr_cc(z_container_POMM[,-c(1:10000)])
similarity_matrixSimple = pr_cc(z_container_Simple[,-c(1:10000)])
#plotting it
similarity_plot(similarity_matrixPOMMM, z_truePOMM, z_truePOMM)
similarity_plot(similarity_matrixSimple, z_trueSimple, z_trueSimple)
#extracting similarity matrix
similarity_matrixPOMMM = pr_cc(z_container_POMM[,-c(1:20000)])
similarity_matrixSimple = pr_cc(z_container_Simple[,-c(1:20000)])
#plotting it
similarity_plot(similarity_matrixPOMMM, z_truePOMM, z_truePOMM)
#extracting similarity matrix
similarity_matrixPOMMM = pr_cc(z_container_POMM[,-c(1:20000)])
similarity_matrixSimple = pr_cc(z_container_Simple[,-c(1:20000)])
#plotting it
similarity_plot(similarity_matrixPOMMM, z_truePOMM, z_truePOMM)
similarity_plot(similarity_matrixSimple, z_trueSimple, z_trueSimple)
#extracting similarity matrix
similarity_matrixPOMMM = pr_cc(z_container_POMM[,-c(1:30000)])
similarity_matrixSimple = pr_cc(z_container_Simple[,-c(1:30000)])
#plotting it
similarity_plot(similarity_matrixPOMMM, z_truePOMM, z_truePOMM)
#extracting similarity matrix
similarity_matrixPOMMM = pr_cc(z_container_POMM[,-c(1:30000)])
similarity_matrixSimple = pr_cc(z_container_Simple[,-c(1:30000)])
#plotting it
similarity_plot(similarity_matrixPOMMM, z_truePOMM, z_truePOMM)
similarity_plot(similarity_matrixSimple, z_trueSimple, z_trueSimple)
ts.plot(A_container_POMM[-c(1:N_iter*0.70)])
ts.plot(A_container_Simple[-c(1:N_iter*0.70)])
acf(A_container_POMM[-c(1:N_iter*0.25)])
acf(A_container_Simple[-c(1:N_iter*0.25)])
ts.plot(A_container_POMM[-c(1:N_iter*0.50)])
ts.plot(A_container_Simple[-c(1:N_iter*0.50)])
acf(A_container_POMM[-c(1:N_iter*0.25)])
acf(A_container_Simple[-c(1:N_iter*0.25)])
ts.plot(A_container_POMM[-c(1:N_iter*0.50)])
ts.plot(A_container_Simple[-c(1:N_iter*0.50)])
#plotting it
similarity_plot(similarity_matrixPOMMM, z_truePOMM, z_truePOMM)
similarity_plot(similarity_matrixSimple, z_trueSimple, z_trueSimple)
obj_Simple$acceptance_rates$acc.count_z
obj_Simple$acceptance_rates$acc.count_p
obj_Simple$acceptance_rates$acc.count_z
obj_POMM$acceptance_rates$acc.count_overlap
obj_POMM$acceptance_rates$acc.count_z
obj_POMM$acceptance_rates$acc.count_p
obj_POMM$acceptance_rates$acc.count_p
mean(obj_POMM$overlap_container[-c(1:10000)])
mean(obj_POMM$alpha_container[-c(1:10000)])
burnin_pPOMM = obj_POMM$p_container[,,-(10000)]
burnin_pSimple = obj_Simple$p_container[,,-(10000)]
p_true_POMM <- obj_POMM$p_true
p_true_Simple <- obj_Simple$p_true
identical(p_true_POMM,p_true_Simple) #another check: they should be identical
K<- nrow(p_true_POMM)
plotsPOMM = list()
for(i in 1:K) {
for(j in 1:K) {
y_try = data.frame(y = as.vector(burnin_pPOMM[i, j,]))
p1 = ggplot(y_try, aes(y)) +
geom_density(fill = "dodgerblue", alpha = 0.5) +
scale_x_log10() +
geom_vline(xintercept = p_true_POMM[i, j], color = "red")+
xlab("probability") +
ylab("Density") +
ggtitle(paste("Density plot of entry ", i, ",", j, sep = ""))
plotsPOMM[[length(plotsPOMM) + 1]] <- p1
}
}
p_combinedPOMM = patchwork::wrap_plots(plotsPOMM, ncol = K, nrow = K)
p_combinedPOMM
p_combinedPOMM
pander::pander(mse_tablePOMM)
mse_tablePOMM = matrix(0,K,K)
for(i in 1:K){
for(j in 1:K){
mse_tablePOMM[i,j]= (mean(burnin_pPOMM[i,j,]) - p_true_POMM[i,j])
}
}
pander::pander(mse_tablePOMM)
point_est_POMM
#point est 1
point_est_POMM = minVI(similarity_matrixPOMMM)$cl
point_est_POMM
point_est_Simple = minVI(similarity_matrixSimple)$cl
point_est_Simple
z_MAP_POMM= z_container_POMM[,which(A_container_POMM == max(A_container_POMM))[1]]
z_MAP_POMM
p_est_pomm <- mean(burnin_pPOMM[,,])
p_est_pomm
p_est_pomm <- mean(burnin_pPOMM[1,2])
p_est_pomm <- mean(burnin_pPOMM[1,2,])
p_est_pomm
p_est_pomm <- mean(burnin_pPOMM[1,3,])
p_est_pomm
p_true_POMM
library(label.switching)
library(collpcm)
collpcm.undo.label.switching(t(z_container_POMM))
collpcm.undo.label.switching(t(z_container_POMM),K)
which(z_container_POMM == 0)
which(is.NA(z_container_POMM)
which(is.NA(z_container_POMM))
which(is.NA(z_container_POMM))
table(is.NA(z_container_POMM))
table(is.na(z_container_POMM))
unique(z_container_POMM)
table(unique(z_container_POMM))
collpcm.undo.label.switching(t(z_container_POMM),rep(K,40000))
label_switch = label.switching(method = "DATA-BASED",z = t(z.container[,-c(1:N_iter*0.5)]),K = K)
label_switch = label.switching(method = "DATA-BASED",z = t(z_container_POMM[,-c(1:N_iter*0.5)]),K = K)
label.switching(zpivot = z_truePOMM,z = t(z_container_POMM[,-c(1:N_iter*0.5)]), K = K)
label.switching(method = 'zpivot' ,zpivot = z_truePOMM,z = t(z_container_POMM[,-c(1:N_iter*0.5)]), K = K)
label.switching(method = 'ECR' ,zpivot = z_truePOMM,z = t(z_container_POMM[,-c(1:N_iter*0.5)]), K = K)
run<- label.switching(method = 'ECR' ,zpivot = z_truePOMM,z = t(z_container_POMM[,-c(1:N_iter*0.5)]), K = K)
permute_array <- function(samples_array, permutation_matrix) {
K <- dim(samples_array)[1]
N_iter <- dim(samples_array)[3]
permuted_array <- array(0, dim = c(K, K, N_iter))
for (i in 1:N_iter) {
permuted_indices <- permutation_matrix[, i]
permuted_array[, , i] <- samples_array[permuted_indices, permuted_indices, i]
}
return(permuted_array)
}
# Example array of samples
samples <- array(1:(3^2 * 4), dim = c(3, 3, 4))
samples
# Example permutation matrix
permutations <- matrix(c(2, 1, 3, 1, 3, 2, 3, 2, 1, 2, 3, 1), nrow = 3, ncol = 4, byrow = TRUE)
permutations
# Example data
array_samples <- array(1:(3^2 * 2), dim = c(3, 3, 2))
perm_matrix <- matrix(c(2, 1, 3, 3, 2, 1), nrow = 2, byrow = TRUE)
perm_matrix
array_samples
# Output the original and permuted arrays
print("Original array:")
print(array_samples)
print("Permuted array:")
print(permuted_array)
# Permute the array
permuted_array <- permute_array(array_samples, perm_matrix)
permute_array <- function(array_samples, perm_matrix) {
N_iter <- dim(array_samples)[3]  # Number of iterations
K <- dim(array_samples)[1]       # Dimension of the array (K by K)
permuted_array <- array(dim = c(K, K, N_iter))  # Initialize permuted array
for (i in 1:N_iter) {
perm_indices <- perm_matrix[i, ]  # Permutation indices for the current iteration
permuted_array[, , i] <- array_samples[perm_indices, perm_indices, i]
}
return(permuted_array)
}
# Example data
array_samples <- array(1:(3^2 * 2), dim = c(3, 3, 2))
perm_matrix <- matrix(c(2, 1, 3, 3, 2, 1), nrow = 2, byrow = TRUE)
# Permute the array
permuted_array <- permute_array(array_samples, perm_matrix)
# Output the original and permuted arrays
print("Original array:")
print(array_samples)
print("Permuted array:")
print(permuted_array)
perm_matrix
run$permutations
# apply the permutations returned by typing:
perm.POMM< -permute_array(array_samples = burnin_pPOMM, perm_matrix = run$permutations)
# apply the permutations returned by typing:
perm.POMM<- permute_array(array_samples = burnin_pPOMM, perm_matrix = run$permutations)
burnin_pPOMM
run<- label.switching(method = 'ECR' ,zpivot = z_truePOMM,z = t(z_container_POMM), K = K)
# apply the permutations returned by typing:
perm.POMM<- permute_array(array_samples = obj_POMM$p_container, perm_matrix = run$permutations)
permute_array <- function(array_samples, perm_matrix) {
N_iter <- dim(array_samples)[3]  # Number of iterations
K <- dim(array_samples)[1]       # Dimension of the array (K by K)
permuted_array <- array(dim = c(K, K, N_iter))  # Initialize permuted array
for (i in 1:N_iter) {
perm_indices <- perm_matrix[i, ]  # Permutation indices for the current iteration
permuted_array[, , i] <- array_samples[perm_indices, perm_indices, i]
}
return(permuted_array)
}
# apply the permutations returned by typing:
perm.POMM<- permute_array(array_samples = obj_POMM$p_container, perm_matrix = run$permutations)
N_iter <- dim(array_samples)[3]  # Number of iterations
N_iter
N_iter <- dim(obj_POMM$p_container)[3]  # Number of iterations
N_iter
K <- dim(obj_POMM$p_container)[1]       # Dimension of the array (K by K)
permuted_array <- array(dim = c(K, K, N_iter))  # Initialize permuted array
for (i in 1:N_iter) {
perm_indices <- run$permutations[i, ]  # Permutation indices for the current iteration
permuted_array[, , i] <- obj_POMM$p_container)[perm_indices, perm_indices, i]
for (i in 1:N_iter) {
perm_indices <- run$permutations[i, ]  # Permutation indices for the current iteration
permuted_array[, , i] <- obj_POMM$p_container[perm_indices, perm_indices, i]
}
run$permutations
run$permutations[1, ]
dim(run$permutations)
for (i in 1:N_iter) {
perm_indices <- as.matrix(run$permutations)[i, ]  # Permutation indices for the current iteration
permuted_array[, , i] <- obj_POMM$p_container[perm_indices, perm_indices, i]
}
for (i in 1:N_iter) {
perm_indices <- as.matrix(run$permutations)[i, ]  # Permutation indices for the current iteration
permuted_array[, , i] <- as.array(obj_POMM$p_container)[perm_indices, perm_indices, i]
}
as.array(obj_POMM$p_container)
perm_indices <- as.matrix(run$permutations)[1, ]
perm_indices <- as.matrix(run$permutations)[i, ]
perm_indices
perm_indices <- as.matrix(run$permutations)[1, ]
perm_indices
for (i in 1:N_iter) {
perm_indices <- as.matrix(run$permutations$ECR)[i, ]  # Permutation indices for the current iteration
permuted_array[, , i] <- as.array(obj_POMM$p_container)[perm_indices, perm_indices, i]
}
permuted_array
# apply the permutations returned by typing:
perm.POMM<- permute_array(array_samples = obj_POMM$p_container, perm_matrix = run$permutations)
# apply the permutations returned by typing:
perm.POMM<- permute_array(array_samples = obj_POMM$p_container, perm_matrix = run$permutations$ECR)
mean(perm.POMM[1,2])
mean(perm.POMM[1,2,])
mean(perm.POMM[1,2,]) - obj_POMM$p_true
mean(perm.POMM[1,2,]) - obj_POMM$p_true[1,2]
mean(perm.POMM[1,3,]) - obj_POMM$p_true[1,3]
mean(perm.POMM[2,3,]) - obj_POMM$p_true[2,3]
obj_POMM$p_true
