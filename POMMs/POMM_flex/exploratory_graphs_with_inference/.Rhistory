alpha_current=alpha
truncations_current = improper_prior5(K=K,beta_max = beta_max,alpha = alpha_current,diag0.5 = T)
p_current = P_data
C_current <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_current,
truncations = truncations_current,
diag0.5 = T)
acc.count_alpha = 0
j_start = ifelse(diag0.5, yes = 1, no = 0)
K_stop = ifelse(diag0.5, yes = K-1, no = K)
for( iter in 1:N_iter){
#proposing a new overlap
overlap_prime <- rtruncnorm(1,a = 0.1,b = 0.9,mean = overlap_current,sd = 0.02)
C_prime <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_prime,
truncations = truncations_current,
diag0.5 = T)
log_r=  C_prime -  C_current
#create statements that check conditiond to accept move
MH_condition_overlap= min(log_r,0)>=log(runif(1))
if(MH_condition_overlap){
acc.count_overlap=acc.count_overlap+1
overlap_current <- overlap_prime
C_current<- C_prime
}
overlap_container[iter]<- overlap_current
}
ts.plot(overlap_container[-c(1:N_iter*0.25)])
acf(overlap_container[-c(1:N_iter*0.25)])
mean(overlap_container[-c(1:N_iter*0.25)])
N_iter = 30000
overlap = 0.3
alpha=.5
beta_max=0.8
K=16
truncations= improper_prior5(K=K,beta_max = beta_max,alpha = alpha,diag0.5 = T)
P_data = simulating_overlapping_POMM_powerlaw_norm(K=K,alpha = alpha,overlap = overlap,truncations = truncations,beta_max = beta_max,diag0.5 = T)
overlap_container = matrix(0, N_iter, 1)
acc.count_overlap = matrix(0, K,K)
overlap_current=0.9
alpha_current=alpha
truncations_current = improper_prior5(K=K,beta_max = beta_max,alpha = alpha_current,diag0.5 = T)
p_current = P_data
C_current <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_current,
truncations = truncations_current,
diag0.5 = T)
acc.count_alpha = 0
j_start = ifelse(diag0.5, yes = 1, no = 0)
K_stop = ifelse(diag0.5, yes = K-1, no = K)
for( iter in 1:N_iter){
#proposing a new overlap
overlap_prime <- rtruncnorm(1,a = 0.1,b = 0.9,mean = overlap_current,sd = 0.02)
C_prime <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_prime,
truncations = truncations_current,
diag0.5 = T)
log_r=  C_prime -  C_current
#create statements that check conditiond to accept move
MH_condition_overlap= min(log_r,0)>=log(runif(1))
if(MH_condition_overlap){
acc.count_overlap=acc.count_overlap+1
overlap_current <- overlap_prime
C_current<- C_prime
}
overlap_container[iter]<- overlap_current
}
ts.plot(overlap_container[-c(1:N_iter*0.25)])
acf(overlap_container[-c(1:N_iter*0.25)])
mean(overlap_container[-c(1:N_iter*0.25)])
N_iter = 30000
overlap = 0.9
alpha=.5
beta_max=0.8
K=16
truncations= improper_prior5(K=K,beta_max = beta_max,alpha = alpha,diag0.5 = T)
P_data = simulating_overlapping_POMM_powerlaw_norm(K=K,alpha = alpha,overlap = overlap,truncations = truncations,beta_max = beta_max,diag0.5 = T)
overlap_container = matrix(0, N_iter, 1)
acc.count_overlap = matrix(0, K,K)
overlap_current=0.9
alpha_current=alpha
truncations_current = improper_prior5(K=K,beta_max = beta_max,alpha = alpha_current,diag0.5 = T)
p_current = P_data
C_current <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_current,
truncations = truncations_current,
diag0.5 = T)
acc.count_alpha = 0
j_start = ifelse(diag0.5, yes = 1, no = 0)
K_stop = ifelse(diag0.5, yes = K-1, no = K)
for( iter in 1:N_iter){
#proposing a new overlap
overlap_prime <- rtruncnorm(1,a = 0.1,b = 0.95,mean = overlap_current,sd = 0.02)
C_prime <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_prime,
truncations = truncations_current,
diag0.5 = T)
log_r=  C_prime -  C_current
#create statements that check conditiond to accept move
MH_condition_overlap= min(log_r,0)>=log(runif(1))
if(MH_condition_overlap){
acc.count_overlap=acc.count_overlap+1
overlap_current <- overlap_prime
C_current<- C_prime
}
overlap_container[iter]<- overlap_current
}
ts.plot(overlap_container[-c(1:N_iter*0.25)])
acf(overlap_container[-c(1:N_iter*0.25)])
mean(overlap_container[-c(1:N_iter*0.25)])
N_iter = 30000
overlap = 0.9
alpha=.5
beta_max=0.8
K=5
truncations= improper_prior5(K=K,beta_max = beta_max,alpha = alpha,diag0.5 = T)
P_data = simulating_overlapping_POMM_powerlaw_norm(K=K,alpha = alpha,overlap = overlap,truncations = truncations,beta_max = beta_max,diag0.5 = T)
overlap_container = matrix(0, N_iter, 1)
acc.count_overlap = matrix(0, K,K)
overlap_current=0.9
alpha_current=alpha
truncations_current = improper_prior5(K=K,beta_max = beta_max,alpha = alpha_current,diag0.5 = T)
p_current = P_data
C_current <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_current,
truncations = truncations_current,
diag0.5 = T)
acc.count_alpha = 0
j_start = ifelse(diag0.5, yes = 1, no = 0)
K_stop = ifelse(diag0.5, yes = K-1, no = K)
for( iter in 1:N_iter){
#proposing a new overlap
overlap_prime <- rtruncnorm(1,a = 0.1,b = 0.95,mean = overlap_current,sd = 0.02)
C_prime <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_prime,
truncations = truncations_current,
diag0.5 = T)
log_r=  C_prime -  C_current
#create statements that check conditiond to accept move
MH_condition_overlap= min(log_r,0)>=log(runif(1))
if(MH_condition_overlap){
acc.count_overlap=acc.count_overlap+1
overlap_current <- overlap_prime
C_current<- C_prime
}
overlap_container[iter]<- overlap_current
}
ts.plot(overlap_container[-c(1:N_iter*0.25)])
acf(overlap_container[-c(1:N_iter*0.25)])
mean(overlap_container[-c(1:N_iter*0.25)])
N_iter = 30000
overlap = 0.9
alpha=.5
beta_max=0.8
K=5
truncations= improper_prior5(K=K,beta_max = beta_max,alpha = alpha,diag0.5 = T)
P_data = simulating_overlapping_POMM_powerlaw_norm(K=K,alpha = alpha,overlap = overlap,truncations = truncations,beta_max = beta_max,diag0.5 = T)
P_data
overlap_container = matrix(0, N_iter, 1)
acc.count_overlap = matrix(0, K,K)
alpha_current=alpha
truncations_current = improper_prior5(K=K,beta_max = beta_max,alpha = alpha_current,diag0.5 = T)
p_current = P_data
C_current <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_current,
truncations = truncations_current,
diag0.5 = T)
acc.count_alpha = 0
j_start = ifelse(diag0.5, yes = 1, no = 0)
K_stop = ifelse(diag0.5, yes = K-1, no = K)
for( iter in 1:N_iter){
#proposing a new overlap
overlap_prime <- rtruncnorm(1,a = 0.1,b = 0.95,mean = overlap_current,sd = 0.02)
C_prime <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_prime,
truncations = truncations_current,
diag0.5 = T)
log_r=  C_prime -  C_current
#create statements that check conditiond to accept move
MH_condition_overlap= min(log_r,0)>=log(runif(1))
if(MH_condition_overlap){
acc.count_overlap=acc.count_overlap+1
overlap_current <- overlap_prime
C_current<- C_prime
}
overlap_container[iter]<- overlap_current
}
ts.plot(overlap_container[-c(1:N_iter*0.25)])
acf(overlap_container[-c(1:N_iter*0.25)])
mean(overlap_container[-c(1:N_iter*0.25)])
K = 3
N_iter = 30000
overlap = 0.9
alpha=.5
beta_max=0.8
K=15
truncations= improper_prior5(K=K,beta_max = beta_max,alpha = alpha,diag0.5 = T)
P_data = simulating_overlapping_POMM_powerlaw_norm(K=K,alpha = alpha,overlap = overlap,truncations = truncations,beta_max = beta_max,diag0.5 = T)
overlap_container = matrix(0, N_iter, 1)
acc.count_overlap = matrix(0, K,K)
alpha_current=alpha
truncations_current = improper_prior5(K=K,beta_max = beta_max,alpha = alpha_current,diag0.5 = T)
p_current = P_data
C_current <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_current,
truncations = truncations_current,
diag0.5 = T)
acc.count_alpha = 0
j_start = ifelse(diag0.5, yes = 1, no = 0)
K_stop = ifelse(diag0.5, yes = K-1, no = K)
for( iter in 1:N_iter){
#proposing a new overlap
overlap_prime <- rtruncnorm(1,a = 0.1,b = 0.95,mean = overlap_current,sd = 0.02)
C_prime <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_prime,
truncations = truncations_current,
diag0.5 = T)
log_r=  C_prime -  C_current
#create statements that check conditiond to accept move
MH_condition_overlap= min(log_r,0)>=log(runif(1))
if(MH_condition_overlap){
acc.count_overlap=acc.count_overlap+1
overlap_current <- overlap_prime
C_current<- C_prime
}
overlap_container[iter]<- overlap_current
}
ts.plot(overlap_container[-c(1:N_iter*0.25)])
acf(overlap_container[-c(1:N_iter*0.25)])
mean(overlap_container[-c(1:N_iter*0.25)])
N_iter = 30000
overlap = 0.9
alpha=.5
beta_max=0.8
K=4
truncations= improper_prior5(K=K,beta_max = beta_max,alpha = alpha,diag0.5 = T)
P_data = simulating_overlapping_POMM_powerlaw_norm(K=K,alpha = alpha,overlap = overlap,truncations = truncations,beta_max = beta_max,diag0.5 = T)
overlap_container = matrix(0, N_iter, 1)
acc.count_overlap = matrix(0, K,K)
alpha_current=alpha
truncations_current = improper_prior5(K=K,beta_max = beta_max,alpha = alpha_current,diag0.5 = T)
p_current = P_data
C_current <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_current,
truncations = truncations_current,
diag0.5 = T)
acc.count_alpha = 0
j_start = ifelse(diag0.5, yes = 1, no = 0)
K_stop = ifelse(diag0.5, yes = K-1, no = K)
for( iter in 1:N_iter){
#proposing a new overlap
overlap_prime <- rtruncnorm(1,a = 0.1,b = 0.95,mean = overlap_current,sd = 0.02)
C_prime <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_prime,
truncations = truncations_current,
diag0.5 = T)
log_r=  C_prime -  C_current
#create statements that check conditiond to accept move
MH_condition_overlap= min(log_r,0)>=log(runif(1))
if(MH_condition_overlap){
acc.count_overlap=acc.count_overlap+1
overlap_current <- overlap_prime
C_current<- C_prime
}
overlap_container[iter]<- overlap_current
}
ts.plot(overlap_container[-c(1:N_iter*0.25)])
acf(overlap_container[-c(1:N_iter*0.25)])
mean(overlap_container[-c(1:N_iter*0.25)])
N_iter = 90000
overlap = 0.9
alpha=.5
beta_max=0.8
K=4
truncations= improper_prior5(K=K,beta_max = beta_max,alpha = alpha,diag0.5 = T)
P_data = simulating_overlapping_POMM_powerlaw_norm(K=K,alpha = alpha,overlap = overlap,truncations = truncations,beta_max = beta_max,diag0.5 = T)
overlap_container = matrix(0, N_iter, 1)
acc.count_overlap = matrix(0, K,K)
alpha_current=alpha
truncations_current = improper_prior5(K=K,beta_max = beta_max,alpha = alpha_current,diag0.5 = T)
p_current = P_data
C_current <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_current,
truncations = truncations_current,
diag0.5 = T)
acc.count_alpha = 0
j_start = ifelse(diag0.5, yes = 1, no = 0)
K_stop = ifelse(diag0.5, yes = K-1, no = K)
for( iter in 1:N_iter){
#proposing a new overlap
overlap_prime <- rtruncnorm(1,a = 0.1,b = 0.95,mean = overlap_current,sd = 0.02)
C_prime <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_prime,
truncations = truncations_current,
diag0.5 = T)
log_r=  C_prime -  C_current
#create statements that check conditiond to accept move
MH_condition_overlap= min(log_r,0)>=log(runif(1))
if(MH_condition_overlap){
acc.count_overlap=acc.count_overlap+1
overlap_current <- overlap_prime
C_current<- C_prime
}
overlap_container[iter]<- overlap_current
}
ts.plot(overlap_container[-c(1:N_iter*0.25)])
acf(overlap_container[-c(1:N_iter*0.25)])
mean(overlap_container[-c(1:N_iter*0.25)])
K
overlap_prime
N_iter = 90000
overlap = 0.9
alpha=.5
beta_max=0.8
K=10
truncations= improper_prior5(K=K,beta_max = beta_max,alpha = alpha,diag0.5 = T)
P_data = simulating_overlapping_POMM_powerlaw_norm(K=K,alpha = alpha,overlap = overlap,truncations = truncations,beta_max = beta_max,diag0.5 = T)
overlap_container = matrix(0, N_iter, 1)
acc.count_overlap = matrix(0, K,K)
alpha_current=alpha
truncations_current = improper_prior5(K=K,beta_max = beta_max,alpha = alpha_current,diag0.5 = T)
p_current = P_data
C_current <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_current,
truncations = truncations_current,
diag0.5 = T)
acc.count_alpha = 0
j_start = ifelse(diag0.5, yes = 1, no = 0)
K_stop = ifelse(diag0.5, yes = K-1, no = K)
for( iter in 1:N_iter){
#proposing a new overlap
overlap_prime <- rtruncnorm(1,a = 0.1,b = 0.95,mean = overlap_current,sd = 0.02)
C_prime <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_prime,
truncations = truncations_current,
diag0.5 = T)
log_r=  C_prime -  C_current
#create statements that check conditiond to accept move
MH_condition_overlap= min(log_r,0)>=log(runif(1))
if(MH_condition_overlap){
acc.count_overlap=acc.count_overlap+1
overlap_current <- overlap_prime
C_current<- C_prime
}
overlap_container[iter]<- overlap_current
}
ts.plot(overlap_container[-c(1:N_iter*0.25)])
acf(overlap_container[-c(1:N_iter*0.25)])
mean(overlap_container[-c(1:N_iter*0.25)])
acc.count_overlap
N_iter = 30000
overlap = 0.3
alpha=.5
beta_max=0.8
K=10
truncations= improper_prior5(K=K,beta_max = beta_max,alpha = alpha,diag0.5 = T)
P_data = simulating_overlapping_POMM_powerlaw_norm(K=K,alpha = alpha,overlap = overlap,truncations = truncations,beta_max = beta_max,diag0.5 = T)
overlap_container = matrix(0, N_iter, 1)
acc.count_overlap = 0
alpha_current=alpha
truncations_current = improper_prior5(K=K,beta_max = beta_max,alpha = alpha_current,diag0.5 = T)
p_current = P_data
C_current <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_current,
truncations = truncations_current,
diag0.5 = T)
acc.count_alpha = 0
j_start = ifelse(diag0.5, yes = 1, no = 0)
K_stop = ifelse(diag0.5, yes = K-1, no = K)
for( iter in 1:N_iter){
#proposing a new overlap
overlap_prime <- rtruncnorm(1,a = 0.1,b = 0.95,mean = overlap_current,sd = 0.02)
C_prime <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_prime,
truncations = truncations_current,
diag0.5 = T)
log_r=  C_prime -  C_current
#create statements that check conditiond to accept move
MH_condition_overlap= min(log_r,0)>=log(runif(1))
if(MH_condition_overlap){
acc.count_overlap=acc.count_overlap+1
overlap_current <- overlap_prime
C_current<- C_prime
}
overlap_container[iter]<- overlap_current
}
ts.plot(overlap_container[-c(1:N_iter*0.25)])
acf(overlap_container[-c(1:N_iter*0.25)])
mean(overlap_container[-c(1:N_iter*0.25)])
N_iter = 30000
overlap = 0.7
alpha=.5
N_iter = 30000
overlap = 0.7
alpha=.5
beta_max=0.8
K=5
truncations= improper_prior5(K=K,beta_max = beta_max,alpha = alpha,diag0.5 = T)
P_data = simulating_overlapping_POMM_powerlaw_norm(K=K,alpha = alpha,overlap = overlap,truncations = truncations,beta_max = beta_max,diag0.5 = T)
overlap_container = matrix(0, N_iter, 1)
acc.count_overlap = 0
alpha_current=alpha
truncations_current = improper_prior5(K=K,beta_max = beta_max,alpha = alpha_current,diag0.5 = T)
p_current = P_data
C_current <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_current,
truncations = truncations_current,
diag0.5 = T)
acc.count_alpha = 0
j_start = ifelse(diag0.5, yes = 1, no = 0)
K_stop = ifelse(diag0.5, yes = K-1, no = K)
for( iter in 1:N_iter){
#proposing a new overlap
overlap_prime <- rtruncnorm(1,a = 0.1,b = 0.95,mean = overlap_current,sd = 0.02)
C_prime <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_prime,
truncations = truncations_current,
diag0.5 = T)
log_r=  C_prime -  C_current
#create statements that check conditiond to accept move
MH_condition_overlap= min(log_r,0)>=log(runif(1))
if(MH_condition_overlap){
acc.count_overlap=acc.count_overlap+1
overlap_current <- overlap_prime
C_current<- C_prime
}
overlap_container[iter]<- overlap_current
}
ts.plot(overlap_container[-c(1:N_iter*0.25)])
acf(overlap_container[-c(1:N_iter*0.25)])
mean(overlap_container[-c(1:N_iter*0.25)])
acc.count_overlap
truncations
N_iter = 30000
overlap = 0.7
alpha=.5
beta_max=0.8
K=5
truncations= improper_prior5(K=K,beta_max = beta_max,alpha = alpha,diag0.5 = T)
P_data = simulating_overlapping_POMM_powerlaw_norm(K=K,alpha = alpha,overlap = overlap,truncations = truncations,beta_max = beta_max,diag0.5 = T)
overlap_container = matrix(0, N_iter, 1)
acc.count_overlap = 0
alpha_current=alpha
truncations_current = improper_prior5(K=K,beta_max = beta_max,alpha = alpha_current,diag0.5 = T)
p_current = P_data
C_current <- l_like_p_ij_normal_overlap(K = K, P_matrix = p_current,overlap =
overlap_current,
truncations = truncations_current,
diag0.5 = T)
alphas_to_be_tested <- c(0.1,0.5,1,1.5,3)
overlap_to_be_tested<- c(0.2,0.4,0.7)
combinations<- expand.grid(alphas_to_be_tested, overlap_to_be_tested)
alphas_to_be_tested <- c(0.1,0.5,1,1.5,3)
overlap_to_be_tested<- c(0.2,0.4,0.7)
combinations<- expand.grid(alphas_to_be_tested, overlap_to_be_tested)
results<- data.frame( alpha = combinations$Var1, S =combinations$Var2, MAE = rep(0, nrow(combinations)))
for (nrow in 1: nrow(results)){
K=5
n_samples=1000
overlap = results$S[nrow]
beta_max = .8
alpha=results$alpha[nrow]
diag0.5=T
true_alpha<-alpha
#creating a sample of P matrices
p_container = array(0, dim=c(K,K,n_samples))
for(i in 1:n_samples){
trunc = improper_prior5(K,alpha = alpha,diag0.5 = diag0.5, beta_max = beta_max )
p_container[,,i] = simulating_overlapping_POMM_powerlaw_norm(K, alpha=alpha, overlap  = overlap, beta_max = beta_max,truncations = trunc,diag0.5 = diag0.5)
}
alpha_test = seq(0.1,4,0.1)
overlap_test = seq(0.1,.9,0.05)
#set the containers
likelihood_est = matrix(0, nrow=n_samples, ncol=length(overlap_test))
for(j in 1: n_samples){
for(i in 1:length(overlap_test)){
trunc_i = improper_prior5(K,beta_max,alpha = alpha,diag0.5 = diag0.5)
likelihood_est[j,i]= l_like_p_ij_normal_overlap(K,p_container[,,j],overlap = overlap_test[i],trunc_i,diag0.5 = diag0.5)
}
}
# Define the function to maximize
likelihood_function <- function(overlap) {
likelihood_est = matrix(0, nrow=n_samples, ncol=1)
for(j in 1: n_samples){
trunc_i = improper_prior5(K,beta_max,alpha,diag0.5 = diag0.5)
likelihood_est[j]= l_like_p_ij_normal_overlap(K,p_container[,,j],overlap = overlap,trunc_i,diag0.5 = diag0.5)
}
return(sum(likelihood_est))
}
# Find the alpha value that maximizes the likelihood_est
max_likelihood <- optimize(likelihood_function, interval = c(0.1, 4), maximum = TRUE)
max_value <- max_likelihood$max
overlap_true <- overlap
max_alpha
results$MAE[nrow] = abs(max_value - overlap)
df_diagnostic = data.frame(overlap = overlap_test, likelihood= colSums(likelihood_est)) %>% filter(likelihood != - Inf)
print(paste("Overlap_Likelihood",K, "Level_sets_alpha_",alpha,"_overlap_",overlap,"_diag_",0.5, sep = "_"))
setwd("/Users/lapo_santi/Desktop/Nial/POMM_pairwise/POMMs/POMM_flex/exploratory_graphs_with_inference")
plot_name <-paste0("Overlap_LikelihoodK",K,"_alpha",alpha,"_overlap",overlap,"_diag_",".png")
lik_plot<- ggplot(df_diagnostic, aes(x = overlap, y = scale(likelihood))) +
geom_line(colour = blue_purple[3]) +
geom_vline(aes(xintercept = overlap_true, colour = blue_purple[1]), alpha = 0.8, show.legend = TRUE) +
geom_vline(aes(xintercept = max_value, colour = "red" ), alpha = 0.8, linetype = "dashed", show.legend = TRUE) +
theme_bw() +
labs(x = "Alpha", y = "Likelihood", title = paste0("Likelihood of overlap = [0.1,3], K= ", K, ", true alpha = ", alpha, ", S = ", overlap)) +
scale_color_manual(values = c("red", blue_purple[4]), labels = c("True Value", "Estimate")) +
guides(colour = guide_legend(title = "Legend"))
png(plot_name,width = 800, height = 518)
print(lik_plot)
dev.off()
}
results
